<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Endless Turn-Based RPG</title>
    <style>
    
    #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 800px;
    margin: 0 auto;
}
        #gameCanvas {
    display: none;
    border: 1px solid black;
    width: 100%;
    max-width: 800px;
    height: auto;
}

#gameButtons, #gameNotifications, #gameVictoryScreen, #gameDefeatScreen, #campScreen, #storyEventScreen, #characterSelectScreen {
    display: none; /* Initially hide all game elements */
}

#gameButtons {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 10px;
    width: 100%;
    position: relative; /* Add this line */
    z-index: 10; /* Add this line */
    
}

#gameButtons button {
    margin: 5px;
    padding: 10px 20px;
    font-size: 16px;
}

#mainMenu {
    text-align: center;
    margin-top: 100px;
}

#startGameButton {
    font-size: 20px;
    padding: 10px 20px;
}

#loadingScreen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 24px;
    z-index: 9999;
}

.loader {
    border: 16px solid #f3f3f3;
    border-top: 16px solid #3498db;
    border-radius: 50%;
    width: 120px;
    height: 120px;
    animation: spin 2s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}


    @keyframes glow {
        0% {
            box-shadow: 0 0 5px #ff00de;
        }
        50% {
            box-shadow: 0 0 20px #ff00de;
        }
        100% {
            box-shadow: 0 0 5px #ff00de;
        }
    }

    #specialAttackButton {
        display: none;
        padding: 10px 20px;
        font-size: 16px;
        border: 2px solid #ff00de;
        background-color: #4a0e4e;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    #specialAttackButton.available {
        animation: glow 1.5s infinite;
    }

    #specialAttackButton.cooldown {
        animation: none;
        background-color: #666;
        border-color: #999;
        color: #ccc;
        cursor: not-allowed;
    }

#characterSelectScreen {
    text-align: center;
    margin-top: 100px;
}

.character-sprite-select {
    width: 150px;  /* Set a fixed width */
    height: 200px; /* Set a fixed height */
    object-fit: contain; /* This will maintain the aspect ratio */
    object-position: center bottom; /* This will align the bottom of the sprites */
}

.character-option {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 200px; /* Set a fixed width for each character option */
    margin: 10px;
}

.character-options {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
}


#shop {
        text-align: center;
    }

    .shop-items {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 5px;
    }

    .shop-item {
        display: inline-block;
        vertical-align: top;
        margin: 0 2px 10px;
        width: 140px;  /* Adjust this width as needed */
    }

    #shop .shop-item button {
        display: block;
        width: 100%;
        margin-bottom: 5px;
        padding: 5px 2px; /* Adjusted padding */
        white-space: normal; /* Allow text to wrap */
        height: auto; /* Allow button to expand vertically */
        line-height: 1.2; /* Adjust line spacing */
        text-align: center;
    }
    
    .button-content {
  display: flex;
  flex-direction: column;
  align-items: center;
}
    .item-description {
        display: block;
        font-size: 0.9em;
        color: #000;
        text-align: center;
    }
    
    .gold-amount {
  font-size: 0.8em;
  color: #333; /* Gold color */
}

#campShop {
    text-align: center;
    margin-top: 20px;
}

#campShop .shop-items {
    display: flex;
    justify-content: center;
    flex-wrap: wrap;
    gap: 5px;
}

#campShop .shop-item {
    display: inline-block;
    vertical-align: top;
    margin: 0 2px 10px;
    width: 140px;
}

#campShop .shop-item button {
    display: block;
    width: 100%;
    margin-bottom: 5px;
    padding: 5px 2px;
    white-space: normal;
    height: auto;
    line-height: 1.2;
    text-align: center;
}

#campShop .button-content {
    display: flex;
    flex-direction: column;
    align-items: center;
}

#campShop .item-description {
    display: block;
    font-size: 0.9em;
    color: #000;
    text-align: center;
}

#campShop .gold-amount {
    font-size: 0.8em;
    color: #333;
}

.tentButton {
    display: block;
    width: 200px;
    height: 50px;
    margin: 10px auto;
    font-size: 16px;
    background-color: #4CAF50;
    color: white;
    border: none;
    cursor: pointer;
}

.tentButton:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

#tentSquares {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    margin-bottom: 20px;
}

.tentRow {
    display: flex;
    flex-direction: row;
    justify-content: center;
    width: 100%;
    margin-bottom: 10px;
}

.tentSquare {
    width: 80px;
    height: 80px;
    background-color: #f0f0f0;
    border: 2px solid #333;
    margin: 0 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    font-size: 12px;
}



#continueJourneyFromCampButton {
    display: block;
    width: 200px;
    height: 50px;
    margin: 20px auto;
    font-size: 16px;
    background-color: #707070;
    color: white;
    border: none;
    cursor: pointer;
}

.bigButton {
    font-size: 1em;
    padding: 5px 10px;
    margin: 5px;
}

/* Add any additional styles for other elements here */
        #developerGoldButton {
            //background-color: #FFD700;
            //color: #000;
            //padding: 10px 20px;
            //margin: 10px;
            //border: none;
            //cursor: pointer;
        }
        
        #developerGoldButton:hover {
           background-color: #FFA500;
        }
        
        
        @media (max-width: 768px) {
          
          .shop-items {
            flex-direction: column;
        }

        .shop-item {
            width: 100%;
        }

        .item-description {
            font-size: 0.9em;
        }
        
    #gameCanvas {
        width: 100%;
        height: auto;
        max-width: 800px;
        max-height: 500px;
    }

    #gameButtons {
        position: fixed;
        bottom: 10px;
        left: 0;
        right: 0;
        background-color: rgba(255, 255, 255, 0.8);
        padding: 10px;
    }

    #mobileMenu {
        position: fixed;
        bottom: 10px;
        right: 10px;
        z-index: 1000;
    }

    #menuToggle {
        font-size: 24px;
        background: rgba(0,0,0,0.5);
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
    }

    #menuContent {
        background: rgba(0,0,0,0.8);
        padding: 10px;
        border-radius: 5px;
    }

    #menuContent button {
        display: block;
        width: 100%;
        margin: 5px 0;
        padding: 10px;
    }

    .bigButton {
        font-size: 1.2em;
        padding: 10px 20px;
    }
}
    </style>
</head>
<body>
    <div id="loadingScreen" style="display: none;">
      <div class="loader"></div>
      <p>Loading game assets...</p>
    </div>
    <div id="mainMenu">
        <h1>Endless Turn-Based RPG</h1>
        <button id="startGameButton">Start New Game</button>
        <br><br>
        <button id="loadGameButton">Load Game</button>
    </div>
    <div id="characterSelectScreen" style="display: none;">
  <h2>Select Your Character</h2>
  <div class="character-options">
    <div class="character-option">
      <img src="images/warrior-sprite.png" alt="Warrior" class="character-sprite-select">
      <button id="warriorButton">Warrior</button>
    </div>
    <div class="character-option">
      <img src="images/mage-sprite.png" alt="Mage" class="character-sprite-select">
      <button id="mageButton">Mage</button>
    </div>
    <div class="character-option">
      <img src="images/cleric-sprite.png" alt="Cleric" class="character-sprite-select">
      <button id="clericButton">Cleric</button>
    </div>
    <div class="character-option">
      <img src="images/rogue-sprite.png" alt="Rogue" class="character-sprite-select">
      <button id="rogueButton">Rogue</button>
    </div>
  </div>
</div>
    <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="500"></canvas>
    <div id="characterSprite"></div>
    <div id="gameButtons">
        <button id="attackButton">Attack</button>
        <button id="defendButton">Defend</button>
        <button id="specialAttackButton" style="display: none;">Special Attack</button>
        <button id="retreatButton">Retreat</button>
    </div>
</div>
    <div id="gameNotifications">
        <p id="notificationText"></p>
    </div>
    <div id="gameVictoryScreen" style="display: none; text-align: center;">
        <h1>Victory!</h1>
        <p id="victoryMessage"></p>
        <p id="goldMessage"></p>
        <button id="developerGoldButton">Developer Gold</button>
                <div id="shop">
    <h2>Shop</h2>
    <div class="shop-items">
        <div class="shop-item">
            <button id="healingPotionButton">
                <div class="button-content">
                    <span class="item-name">Buy Healing Potion</span>
                    <span class="gold-amount">100 Gold</span>
                </div>
            </button>
            <span class="item-description">Heal 25 HP</span>
        </div>
        <div class="shop-item">
            <button id="expBoosterButton">
                <div class="button-content">
                    <span class="item-name">Buy EXP Booster</span>
                    <span class="gold-amount">200 Gold</span>
                </div>
            </button>
            <span class="item-description">Double the next XP gained</span>
        </div>
        <div class="shop-item">
            <button id="antidoteButton">
                <div class="button-content">
                    <span class="item-name">Buy Antidote</span>
                    <span class="gold-amount">300 Gold</span>
                </div>
            </button>
            <span class="item-description">Heals poison</span>
        </div>
        <div class="shop-item">
            <button id="lotusButton">
                <div class="button-content">
                    <span class="item-name">Buy Lotus of Experience</span>
                    <span class="gold-amount">500 Gold</span>
                </div>
            </button>
            <span class="item-description">Grants 10 XP</span>
        </div>
        <div class="shop-item">
            <button id="redPillButton">
                <div class="button-content">
                    <span class="item-name">Buy Red Pill</span>
                    <span class="gold-amount">1000 Gold</span>
                </div>
            </button>
            <span class="item-description">+1 Min Damage</span>
        </div>
    </div>
</div>
        <br><br>
        <div id="journeyButtons">
            <button id="continueJourneyButton" class="bigButton">Continue Journey</button>
            <button id="returnToCampButton" class="bigButton">Return to Camp</button>
        </div>
        <div id="skillSelection" style="display: none;">
    <h2>Choose Your Special Skill</h2>
    <div id="skillSelectionMageSkills" style="display: none;">
        <button id="thunderButton">Thunder</button>
        <button id="fireballButton">Fireball</button>
        <button id="hailStormButton">Hail Storm</button>
    </div>
    <div id="skillSelectionWarriorSkills" style="display: none;">
        <button id="doubleAttackButton">Double Attack</button>
        <button id="stoneSkinButton">Stone Skin</button>
        <button id="lifeAttackButton">Life Attack</button>
    </div>
    <div id="skillSelectionClericSkills" style="display: none;">
        <button id="holyLightButton">Holy Light</button>
        <button id="lifeTransferButton">Life Transfer</button>
        <button id="shieldOfLightButton">Shield of Light</button>
    </div>
    <div id="skillSelectionRogueSkills" style="display: none;">
        <button id="blindShotButton">Blind Shot</button>
        <button id="toxicStabButton">Toxic Stab</button>
        <button id="perfectParryButton">Perfect Parry</button>
    </div>
    
</div>
        <!-- <button id="continueJourneyButton">Continue Journey</button>
        <button id="returnToCampButton">Return to Camp</button>
        <button id="developerButton">Level Up to 3</button>
        <button id="developerButton5">Level Up to 5</button> -->
    </div>
    <div id="duelVictoryScreen" style="display: none; text-align: center;">
        <h1>Duel Victory!</h1>
        <p id="duelVictoryMessage"></p>
        <button id="recruitButton">Recruit Character</button>
        <button id="continueDuelJourneyButton">Continue Journey</button>
    </div>
    <div id="gameDefeatScreen" style="display: none; text-align: center;">
        <h1>Defeat!</h1>
        <p>You have been defeated.</p>
        <button id="tryAgainButton">Try Again</button>
    </div>
    <div id="campScreen" style="display: none; text-align: center;">
    <h1>Camp</h1>
    <p>Store your gold in the Camp Bank for safekeeping.</p>
    <button id="storeGoldButton">Store All Gold</button>
    <p id="campMessage"></p>
    <div id="tentSquares">
    <div id="playerTentsRow" class="tentRow">
        <div id="tent1" class="tent">
            <strong>Tent 1</strong><br>
            <span class="tent-occupant">Player</span>
        </div>
        <div id="tent2" class="tent" style="display: none;">
            <strong>Tent 2</strong><br>
            <span class="tent-occupant">Empty</span>
        </div>
        <div id="tent3" class="tent" style="display: none;">
            <strong>Tent 3</strong><br>
            <span class="tent-occupant">Empty</span>
        </div>
        <div id="tent4" class="tent" style="display: none;">
            <strong>Tent 4</strong><br>
            <span class="tent-occupant">Empty</span>
        </div>
        <div id="tent5" class="tent" style="display: none;">
            <strong>Tent 5</strong><br>
            <span class="tent-occupant">Empty</span>
        </div>
    </div>
    <div id="commercialTentsRow" class="tentRow"></div>
</div>
    <div id="tentUpgrades">
        <button id="secondTentButton" class="tentButton">Buy Second Tent (1500 Gold)</button>
        <button id="thirdTentButton" class="tentButton" style="display: none;">Buy Third Tent (2000 Gold)</button>
        <button id="fourthTentButton" class="tentButton" style="display: none;">Buy Fourth Tent (2500 Gold)</button>
        <button id="fifthTentButton" class="tentButton" style="display: none;">Buy Fifth Tent (3000 Gold)</button>
        <button id="merchantTentButton" class="tentButton">Buy Merchant Tent (1000 Gold)</button>
    </div>
    <button id="continueJourneyFromCampButton">Continue Journey</button>
    <button id="saveGameButton">Save Game</button>
</div>
    <div id="storyEventScreen" style="display: none; text-align: center;">
        <h1>Story Event</h1>
        <p id="storyText"></p>
        <div id="storyChoices">
            <button id="storyChoice1Button"></button>
            <button id="storyChoice2Button"></button>
            <button id="storyChoice3Button"></button>
        </div>
        <div id="storySkillSelection" style="display: none;">
    <h2>Choose Your Special Skill</h2>
    <div id="storySkillSelectionMageSkills" style="display: none;">
        <button id="storyThunderButton">Thunder</button>
        <button id="storyFireballButton">Fireball</button>
        <button id="storyHailStormButton">Hail Storm</button>
    </div>
    <div id="storySkillSelectionWarriorSkills" style="display: none;">
        <button id="storyDoubleAttackButton">Double Attack</button>
        <button id="storyStoneSkinButton">Stone Skin</button>
        <button id="storyLifeAttackButton">Life Attack</button>
    </div>
    <div id="storySkillSelectionClericSkills" style="display: none;">
        <button id="storyHolyLightButton">Holy Light</button>
        <button id="storyLifeTransferButton">Life Transfer</button>
        <button id="storyShieldOfLightButton">Shield of Light</button>
    </div>
    <div id="storySkillSelectionRogueSkills" style="display: none;">
        <button id="storyBlindShotButton">Blind Shot</button>
        <button id="storyToxicStabButton">Toxic Stab</button>
        <button id="storyPerfectParryButton">Perfect Parry</button>
    </div>
</div>
        <p id="storyStats"></p>
        <p id="storyLevelUpMessage" style="display: none;"></p>
        <button id="continueJourneyFromStoryButton" style="display: none;">Continue Journey</button>
        <button id="continueToBattleButton" style="display: none;">Continue to Battle</button>
    </div>
    <div id="duelEventScreen" style="display: none; text-align: center;">
    <h2>Duel Challenge</h2>
    <p id="duelText"></p>
    <button id="startDuelButton">Start Duel</button>
</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let player = {
    class: '',
    specialSkills: {},
    specialAttackCooldown: 0,
    health: 50,
    maxHealth: 50,
    minDamage: 1,
    maxDamage: 6,
    experience: 0,
    level: 1,
    xpToNextLevel: 20,
    gold: 0,
    campBank: 0,
    expBooster: false,
    defending: false,
    specialAttackCooldown: 0,
    specialSkillUnlocked: false,
    specialSkill: null,
    healthGain: 0,
    minDamageGain: 0,
    maxDamageGain: 0,
	recruitedCharacters: [],
	party: [],  // New party array
    tents: 1,
    poisonCounter: 0,
	hpRegen: 0
    
};

player.purchasedItems = {
    healingPotion: false,
    expBooster: false,
    antidote: false,
    lotus: false,
    redPill: false
};

        const enemyTypes = [
            { type: 'Goblin', baseHP: 20, minDamage: 1, maxDamage: 6, xp: 10 },
            { type: 'Wolf', baseHP: 25, minDamage: 2, maxDamage: 6, xp: 11 },
            { type: 'Orc', baseHP: 30, minDamage: 2, maxDamage: 7, xp: 12 },
            { type: 'Poisonous Plant', baseHP: 28, minDamage: 2, maxDamage: 8, xp: 13 },
            { type: 'Werewolf', baseHP: 35, minDamage: 2, maxDamage: 9, xp: 14 },
            { type: 'Troll', baseHP: 40, minDamage: 3, maxDamage: 8, xp: 15 },
            { type: 'Dragon', baseHP: 70, minDamage: 5, maxDamage: 12, xp: 24 },
            { type: 'Skeletal Warrior', baseHP: 45, minDamage: 4, maxDamage: 10, xp: 18 },
            { type: 'Treant', baseHP: 75, minDamage: 6, maxDamage: 14, xp: 25 },
			{ type: 'Angry Spirit', baseHP: 50, minDamage: 4, maxDamage: 11, xp: 17 }
        ];
        
        const characterSprites = {};
		const enemySprites = {};

        let enemies = []; // Initialize enemies array
        
        let duelEventsUnlocked = false;
        
        let isProcessingPurchase = false;
		
        let selectedEnemyIndex = 0; // Track the selected enemy

        let damageDisplay = {
            player: { damage: 0, x: 0, y: 0, alpha: 0 },
            enemy: { damage: 0, x: 0, y: 0, alpha: 0 }
        };

        let healingDisplay = {
            amount: 0,
            x: 0,
            y: 0,
            alpha: 0
        };
		
		let merchantUpgrades = {
			additionalPotions: false
		};

        let gameState = 'mainMenu'; // Start with the main menu
        let victoryExpGained = 0;
        let currentBattleExpGained = 0; // Track XP gained from the current battle
        let victoryLevelUpMessage = '';
        let inStoryEvent = false; // Flag to indicate if we are in a story event
        let treantEncountered = false; // Track if the player has encountered the Treant
        let currentVictoryScreenPurchases = {};
		if (!merchantUpgrades.hasOwnProperty('flexibleCurrency')) {
				merchantUpgrades.flexibleCurrency = false;
			}
		if (!merchantUpgrades.hasOwnProperty('increasedPotionPotency')) {
			merchantUpgrades.increasedPotionPotency = false;
			}
		if (!merchantUpgrades.hasOwnProperty('massProducedAntidote')) {
				merchantUpgrades.massProducedAntidote = false;
			}
		if (!merchantUpgrades.hasOwnProperty('improvedLotusHarvesting')) {
			merchantUpgrades.improvedLotusHarvesting = false;
			}	
		

        // Flags for story events
        let currentStory = null;
		let currentStoryContext = null;
        const STORY_OLD_MAN = 'old_man';
        const STORY_TREANT = 'treant';
		const STORY_ABANDONED_HOUSE = 'abandonedHouse';
		const STORY_CHILLING_SCREAM = 'chillingScream';
        
        // Add these new functions
function showLoadingScreen() {
    document.getElementById('loadingScreen').style.display = 'flex';
}

function hideLoadingScreen() {
    document.getElementById('loadingScreen').style.display = 'none';
}

function loadInitialGameAssets() {
    const characterClasses = ['Warrior', 'Mage', 'Cleric', 'Rogue'];
    const spriteLoadPromises = characterClasses.map(loadCharacterSprite);
	
	 // Add enemy sprite loading
    const enemyTypes = ['Wolf', 'Goblin', 'Orc', 'Poisonous Plant', 'Werewolf', 'Troll', 'Treant', 'Skeletal Warrior',];
    const enemySpriteLoadPromises = enemyTypes.map(loadEnemySprite);

    return Promise.all([
        ...spriteLoadPromises,
		...enemySpriteLoadPromises,
        // Add other initial asset loading promises here if needed
    ]);
}

function loadCharacterAssets(characterClass) {
    return loadCharacterSprite(characterClass);
}

function loadEnemySprite(enemyType) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            enemySprites[enemyType] = img;
            resolve(img);
        };
        img.onerror = reject;
        img.src = `images/${enemyType.toLowerCase()}-sprite.png`;
    });
}

// Modify your existing initGame function
function initGame() {
    // Hide all game screens
    const screensToHide = [
        'gameCanvas', 'gameButtons', 'gameNotifications', 'gameVictoryScreen',
        'gameDefeatScreen', 'campScreen', 'storyEventScreen', 'characterSelectScreen'
    ];
    screensToHide.forEach(screenId => {
        document.getElementById(screenId).style.display = 'none';
    });

    // Show loading screen
    showLoadingScreen();
	player.party = [];  // Initialize empty party array

    // Load initial game assets
    loadInitialGameAssets().then(() => {
        // Hide loading screen
        hideLoadingScreen();

         // Show main menu instead of character select screen
        document.getElementById('mainMenu').style.display = 'block';

        // Set up event listeners
        if (isMobile()) {
            createMobileEnemySelectionOverlay();
            canvas.addEventListener('touchstart', handleMouseClick, false);
        } else {
            canvas.addEventListener('click', handleMouseClick, false);
        }

        // Any other initialization code...

    }).catch(error => {
        console.error('Failed to load initial game assets:', error);
        hideLoadingScreen();
        // Handle the error (show an error message to the user)
    });
}

            

        function loadCharacterSprite(characterClass) {
            if (!characterSprites[characterClass]) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        characterSprites[characterClass] = img;
                        resolve(img);
                    };
                    img.onerror = reject;
                    img.src = `images/${characterClass.toLowerCase()}-sprite.png`;
                });
            }
            return Promise.resolve(characterSprites[characterClass]);
        }

        // Call initGame when the page loads
        window.onload = initGame;

        function createEnemyByType(type) {
			console.log("Creating enemy of type:", type);
			
			if (!enemyTypes) {
				console.error("enemyTypes is not defined");
				return null;
			}
			
			const enemyType = enemyTypes.find(enemy => enemy.type === type);
			
			if (!enemyType) {
				console.error("Enemy type not found:", type);
				console.log("Available enemy types:", enemyTypes.map(e => e.type));
				return null;
			}
			
			const enemy = {
				type: enemyType.type,
				health: enemyType.baseHP,
				maxHealth: enemyType.baseHP,
				minDamage: enemyType.minDamage,
				maxDamage: enemyType.maxDamage,
				xp: enemyType.xp
				
			};
			
			// Add sprite if it exists
    if (enemySprites[enemyType.type]) {
        enemy.sprite = enemySprites[enemyType.type];
    }
			
			console.log("Created enemy:", enemy);
			return enemy;
		}

        function createEnemies(playerLevel) {
            let enemies = [];
            const doubleBattleChance = Math.random();
            const numberOfEnemies = playerLevel >= 5 && doubleBattleChance <= 0.25 ? 2 : 1;

            for (let i = 0; i < numberOfEnemies; i++) {
                let possibleEnemies = treantEncountered ? enemyTypes : enemyTypes.filter(type => type.type !== 'Treant');
                let enemyIndex;
                if (playerLevel < 3) {
                    enemyIndex = Math.floor(Math.random() * 2); // Goblin or Wolf
                } else if (playerLevel < 4) {
                    enemyIndex = Math.floor(Math.random() * 4); // Goblin, Wolf, Orc
                } else if (playerLevel < 5) {
                    enemyIndex = Math.floor(Math.random() * 5); // Goblin, Wolf, Orc, Werewolf
                } else {
                    enemyIndex = Math.floor(Math.random() * possibleEnemies.length);
                }
                enemies.push(createEnemyByType(possibleEnemies[enemyIndex].type));
            }
            return enemies.map(enemy => ({
				...enemy,
				stunnedTurns: 0,
				burnedTurns: 0
			}));
		}
		
	  let resizeTimeout;
		
    function addButtonListeners() {
    document.getElementById('attackButton').onclick = playerAttack;
    document.getElementById('defendButton').onclick = playerDefend;
    document.getElementById('retreatButton').onclick = playerRetreat;
    document.getElementById('specialAttackButton').onclick = playerSpecialAttack;
}

        // Call it initially to set up the correct size
        window.addEventListener('resize', function() {
    if (isMobile()) {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            resizeGame();
            addButtonListeners();
        }, 100);
    }
});

        function startGame(isNewGame = true) {
    console.log("startGame function called, isNewGame:", isNewGame);
    
    if (isNewGame) {
        // Reset player and game state to initial values
        player = {
            class: '',
            specialSkills: {},
			specialAttackCooldown: 0,
			health: 50,
			maxHealth: 50,
			minDamage: 1,
			maxDamage: 6,
			experience: 0,
			level: 1,
			xpToNextLevel: 20,
			gold: 0,
			campBank: 0,
			expBooster: false,
			defending: false,
			specialSkillUnlocked: false,
			specialSkill: null,
			healthGain: 0,
			minDamageGain: 0,
			maxDamageGain: 0,
			recruitedCharacters: [],
			party: [],  // New party array
			tents: 1,
			poisonCounter: 0
            // Add any other initial player properties here
        };
        
        gameState = 'characterSelect';
        currentStory = null;
        treantEncountered = false;
        duelEventsUnlocked = false;
        resetPurchasedItems();

        hideAllScreens();
        document.getElementById('characterSelectScreen').style.display = 'block';
    } else {
        // This is a loaded game
        hideAllScreens();
        showCampScreen();
    }

    addButtonListeners();
    updateLoadGameButton();
    
    if (isMobile()) {
        resizeGame();
    }
}

        function startBattle(characterClass) {
    console.log("Starting battle with class:", characterClass || player.class);
    console.log("Player special skill:", player.specialSkill);
    showLoadingScreen();

   // Ensure we have a valid character class
    const selectedClass = characterClass || player.class;
    if (!selectedClass) {
        console.error('No character class selected');
        hideLoadingScreen();
        return; // Exit the function if no class is selected
    }

    loadCharacterAssets(selectedClass).then(() => {
        if (characterClass) {
            player.class = characterClass;
            setupClassSkills();
        }
    
    hideAllScreens();
    
    const gameContainer = document.getElementById('gameContainer');
    gameContainer.style.display = 'flex';
    
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('gameButtons').style.display = 'flex';
    
       // Update the special attack button
    //updateSpecialAttackButton();
    
    currentBattleExpGained = 0;
    gameState = 'playerTurn';
    updateButtonStates();
    enemies = createEnemies(player.level);
    
    if (isMobile()) {
        resizeGame();
    }
    
    hideLoadingScreen();
        drawGame();
        animateDamage();
    }).catch(error => {
        console.error('Failed to start battle:', error);
        hideLoadingScreen();
        // Handle the error (show an error message to the user)
    });
}

// Modify the event listeners for character selection buttons
document.getElementById('warriorButton').addEventListener('click', () => startBattle('Warrior'));
document.getElementById('mageButton').addEventListener('click', () => {
    startBattle('Mage');
});
document.getElementById('clericButton').addEventListener('click', () => startBattle('Cleric'));
document.getElementById('rogueButton').addEventListener('click', () => startBattle('Rogue'));

        let lastPoisonStatus = null;
        

    function drawGame() {
	//console.log("Drawing game. Game state:", gameState);
    //console.log("Enemies:", enemies);
	
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
	 //console.log("Canvas dimensions:", canvas.width, "x", canvas.height);
    
    ctx.clearRect(0, 0, 800, 500);
    
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    // Draw player
    
    // Draw player
    drawParty(ctx);
    
    // Draw player status effects
    let playerStatusY = 260;
    const drawStatus = (text, color) => {
        ctx.fillStyle = color;
        ctx.font = '14px Arial';
        ctx.fillText(text, 50, playerStatusY);
        playerStatusY += 20;
    };

    if (player.defending) drawStatus('Defending', 'blue');
    if (player.burnedTurns > 0) drawStatus(`Burned (${player.burnedTurns} turns)`, 'orange');
    if (player.poisonCounter && player.poisonCounter > 0) {
        const poisonStatus = `Poisoned (${player.poisonCounter - 1} damage next turn)`;
        drawStatus(poisonStatus, 'purple');
        if (poisonStatus !== lastPoisonStatus) {
            console.log(`Drawing poison status: ${poisonStatus}`);
            lastPoisonStatus = poisonStatus;
        }
    } else if (lastPoisonStatus !== null) {
        console.log("Player no longer poisoned");
        lastPoisonStatus = null;
    }
    if (player.blind) drawStatus(`Blinded (${player.blind}% chance)`, 'gray');
    if (player.parry) drawStatus('Parry Ready', 'red');
    if (player.shieldOfLight > 0) drawStatus(`Shield of Light (${player.shieldOfLight} turns)`, 'yellow');

    // Draw enemies
enemies.forEach((enemy, index) => {
    let yOffset;
    if (index === 0) {
        // First enemy (top)
        yOffset = 70; // Reduced from 100 to move the first enemy up by 30 pixels
    } else {
        // Second enemy (bottom)
        yOffset = 270; // This should keep the second enemy in its current position
    }
    const hpBarYOffset = yOffset - 30;
    const hpTextYOffset = hpBarYOffset - 10;
    const typeTextYOffset = yOffset + 185;

        // In the drawGame function, replace the part you mentioned with this:
if (enemies.length > 1) {
    if (isMobile()) {
        // For mobile, we'll use the overlay created earlier
        const overlay = document.getElementById('mobileEnemySelectionOverlay');
        overlay.style.display = 'block';
    } else {
        // For desktop, we'll keep the existing selection indicator
        if (index === selectedEnemyIndex) {
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 5;
            ctx.strokeRect(645, yOffset - 5, 60, 60);
        }
    }
}

         // Draw enemy sprite if available, otherwise draw red rectangle
         if (enemy.sprite) {
			const spriteWidth = 180;  // Adjust as needed
			const spriteHeight = 180; // Adjust as needed
			ctx.drawImage(enemy.sprite, 550, yOffset, spriteWidth, spriteHeight);
		} else {
			ctx.fillStyle = 'red';
			ctx.fillRect(650, yOffset, 50, 50);
		}

        ctx.fillStyle = 'green';
        ctx.fillRect(540, hpBarYOffset, (enemy.health / enemy.maxHealth) * 200, 20);

        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.fillText(`Enemy Health: ${enemy.health}`, 540, hpBarYOffset - 25); // Changed from hpTextYOffset to hpBarYOffset - 10
        ctx.fillText(`${enemy.type}`, 620, typeTextYOffset);

        let statusY = typeTextYOffset + 20;
        const drawEnemyStatus = (text, color = 'black') => {
            ctx.fillStyle = color;
            ctx.font = '14px Arial';
            ctx.fillText(text, 650, statusY);
            statusY += 20;
        };

        if (enemy.defending) drawEnemyStatus('Defending');
        if (enemy.stunnedTurns > 0) drawEnemyStatus('Stunned', 'yellow');
        if (enemy.burnedTurns > 0) drawEnemyStatus('Burned', 'orange');
        if (enemy.exposed) drawEnemyStatus('Exposed', 'green');
        if (enemy.blind) drawEnemyStatus(`Blind (${enemy.blind}% chance to miss)`, 'gray');
        if (enemy.poison && enemy.poison > 0) drawEnemyStatus(`Poisoned (${enemy.poison})`, 'purple');
    });

    // Draw player stats
    // Health bar
const healthBarWidth = 200;
const healthBarHeight = 20;
const healthBarX = 10;
const healthBarY = 10;
const healthPercentage = player.health / player.maxHealth;

// Background (red)
ctx.fillStyle = 'red';
ctx.fillRect(healthBarX, healthBarY, healthBarWidth, healthBarHeight);

// Foreground (green)
ctx.fillStyle = 'green';
ctx.fillRect(healthBarX, healthBarY, healthBarWidth * healthPercentage, healthBarHeight);

// Health text
const healthText = `${player.health}/${player.maxHealth} HP`;
ctx.font = '14px Arial';
ctx.textAlign = 'left';
const healthTextY = healthBarY + healthBarHeight / 4;

// Measure text width
const textWidth = ctx.measureText(healthText).width;
const startX = healthBarX + (healthBarWidth - textWidth) / 2;

// Draw each character with appropriate color
for (let i = 0; i < healthText.length; i++) {
    const char = healthText[i];
    const charWidth = ctx.measureText(char).width;
    const charX = startX + ctx.measureText(healthText.substring(0, i)).width;
    const charCenterX = charX + charWidth / 2;

    if (charCenterX <= healthBarX + healthBarWidth * healthPercentage) {
        ctx.fillStyle = 'black';
    } else {
        ctx.fillStyle = 'white';
    }

    ctx.fillText(char, charX, healthTextY);
}


    ctx.textAlign = 'left';
    ctx.font = '16px Arial';
	ctx.fillStyle = 'black';
	ctx.fillText(`Level: ${player.level}`, 10, 35);

    // XP Progress Bar
    const xpBarWidth = 200;
    const xpBarHeight = 20;
    const xpBarX = 10;
    const xpBarY = 55;

    ctx.fillStyle = 'lightgrey';
    ctx.fillRect(xpBarX, xpBarY, xpBarWidth, xpBarHeight);

    const xpProgress = (player.experience / player.xpToNextLevel) * xpBarWidth;
    ctx.fillStyle = 'grey';
    ctx.fillRect(xpBarX, xpBarY, xpProgress, xpBarHeight);

    ctx.fillStyle = 'black';
    ctx.font = '14px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${player.experience}/${player.xpToNextLevel} XP`, xpBarX + xpBarWidth / 2, xpBarY + xpBarHeight / 4);

    ctx.textAlign = 'left';
	ctx.font = '16px Arial';
    ctx.fillText(`Gold: ${player.gold}`, 10, 80);
	ctx.fillText(`Camp Bank: ${player.campBank} Gold`, 10, 470);

    displayDamage();
    updateSpecialAttackButton();
    drawTurnIndicator();
}
		
		const classPositions = {
    Warrior: { x: 45, y: 130 },
    Mage: { x: 45, y: 130 },
    Cleric: { x: 45, y: 130 },
    Rogue: { x: 45, y: 130 }
};

const partyPositions = [
    { x: 45, y: 130 },    // Leader (current player position)
    { x: 145, y: 130 },   // Party member 1
    { x: 245, y: 130 },   // Party member 2
    { x: 345, y: 130 },   // Party member 3
    { x: 445, y: 130 }    // Party member 4
];

function drawPartyMember(ctx, character, position) {
    if (character.class && characterSprites[character.class]) {
        const sprite = characterSprites[character.class];
        const spriteWidth = sprite.width / 2;
        const spriteHeight = sprite.height / 2;
        
        const spriteX = position.x;
        const spriteY = position.y;

        ctx.drawImage(sprite, spriteX, spriteY, spriteWidth, spriteHeight);

        ctx.fillStyle = 'black';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        const textX = spriteX + spriteWidth / 2;
        const textY = spriteY + spriteHeight + 25;
        ctx.fillText(character.class, textX, textY);
        
        ctx.textAlign = 'left';
    }
}

function drawParty(ctx) {
    // Draw the leader (current player)
    drawPartyMember(ctx, player, partyPositions[0]);

    // Draw other party members
    player.party.forEach((member, index) => {
        if (index < 4) {  // Limit to 4 additional party members
            drawPartyMember(ctx, member, partyPositions[index + 1]);
        }
    });
}
		
        function displayDamage() {
            ctx.font = '20px Arial';
            ctx.fillStyle = `rgba(255, 0, 0, ${damageDisplay.enemy.alpha})`;
            ctx.fillText(`-${damageDisplay.enemy.damage}`, damageDisplay.enemy.x, damageDisplay.enemy.y);

            ctx.fillStyle = `rgba(0, 0, 255, ${damageDisplay.player.alpha})`;
            ctx.fillText(`-${damageDisplay.player.damage}`, damageDisplay.player.x, damageDisplay.player.y);

            ctx.fillStyle = `rgba(0, 255, 0, ${healingDisplay.alpha})`;
            ctx.fillText(`+${healingDisplay.amount}`, healingDisplay.x, healingDisplay.y);
        }

        function animateDamage() {
            const animationDuration = 1; // Duration of the animation in seconds
            const framesPerSecond = 60; // Assuming 60 frames per second
            const alphaDecrement = 1 / (animationDuration * framesPerSecond); // How much alpha decreases each frame
            const positionDecrement = 1; // How much position decreases each frame

            if (damageDisplay.enemy.alpha > 0) {
                damageDisplay.enemy.y -= positionDecrement;
                damageDisplay.enemy.alpha -= alphaDecrement;
            }

            if (damageDisplay.player.alpha > 0) {
                damageDisplay.player.y -= positionDecrement;
                damageDisplay.player.alpha -= alphaDecrement;
            }

            if (healingDisplay.alpha > 0) {
                healingDisplay.y -= positionDecrement;
                healingDisplay.alpha -= alphaDecrement;
            }

            drawGame();
            if (damageDisplay.enemy.alpha > 0 || damageDisplay.player.alpha > 0 || healingDisplay.alpha > 0) {
                requestAnimationFrame(animateDamage);
            }
        }

        function resetDamageDisplay() {
            damageDisplay = {
                player: { damage: 0, x: 0, y: 0, alpha: 0 },
                enemy: { damage: 0, x: 0, y: 0, alpha: 0 }
            };

            healingDisplay = {
                amount: 0,
                x: 0,
                y: 0,
                alpha: 0
            };
        }

        function resetGame() {
    player.health = player.maxHealth;
    player.experience = 0;
    player.gold = 0;
    player.expBooster = false;
    player.defending = false;
    player.specialAttackCooldown = 0;
    player.poisonCounter = 0;
    player.burnedTurns = 0;
    player.blind = 0;
    player.shieldOfLight = 0;
    player.parry = false;

    enemies = createEnemies(player.level);
    gameState = 'playerTurn';

    hideDefeatScreen();
    
    const gameContainer = document.getElementById('gameContainer');
    gameContainer.style.display = 'flex';
    
    canvas.style.display = 'block';
    const gameButtons = document.getElementById('gameButtons');
    gameButtons.style.display = 'flex';
    gameButtons.style.justifyContent = 'center';
    gameButtons.style.width = '100%';

    // Reset button states
    updateButtonStates();

    drawGame();
    animateDamage();
}

        //function developerReset() {
         //   player.health = player.maxHealth; // Reset player's health to max
        //    player.defending = false; // Reset defending state
        //    player.specialAttackCooldown = 0; // Reset special attack cooldown

        //    enemies = createEnemies(player.level); // Create new enemies for the player to battle

         //   gameState = 'playerTurn'; // Set game state to player turn

        //    drawGame(); // Redraw the game state
         //   animateDamage(); // Start damage animation
        //}

        function showPlayerTurnNotification() {
            if (gameState !== 'victory' && gameState !== 'defeat') {
                const notificationElement = document.getElementById('notificationText');
                notificationElement.textContent = 'Player Turn';
                setTimeout(() => {
                    if (gameState !== 'victory' && gameState !== 'defeat') {
                        notificationElement.textContent = '';
                    }
                }, 1000);
            }
        }

        function showEnemyTurnNotification() {
            if (gameState !== 'victory' && gameState !== 'defeat') {
                const notificationElement = document.getElementById('notificationText');
                notificationElement.textContent = 'Enemy Turn';
                setTimeout(() => {
                    if (gameState !== 'victory' && gameState !== 'defeat') {
                        notificationElement.textContent = '';
                    }
                }, 1000);
            }
        }

        function playerAttack() {
    if (gameState === 'playerTurn') {
        showPlayerTurnNotification();
        
        if (player.specialAttackCooldown > 0) {
            player.specialAttackCooldown--;
            console.log("Special attack cooldown decreased to:", player.specialAttackCooldown);
        }
        
        const targetEnemy = enemies[selectedEnemyIndex];
        let damage = Math.floor(Math.random() * (player.maxDamage - player.minDamage + 1)) + player.minDamage;
        
        if (targetEnemy.parryNextAttack) {
            console.log("Enemy parried the attack!");
            damageDisplay.player.damage = damage;
            damageDisplay.player.x = 75;
            damageDisplay.player.y = 150;
            damageDisplay.player.alpha = 1;
            player.health -= damage;
            targetEnemy.parryNextAttack = false;
            damage = 0;
        } else {
            if (targetEnemy.exposed) {
                damage *= 2;
                targetEnemy.exposed = false;
            }
            
            if (targetEnemy.defending) {
                damage = Math.floor(damage / 2);
                targetEnemy.defending = false;
            }
            targetEnemy.health -= damage;
            damageDisplay.enemy.damage = damage;
            damageDisplay.enemy.x = 725;
            damageDisplay.enemy.y = 150 + (selectedEnemyIndex * 130);
            damageDisplay.enemy.alpha = 1;
        }
        
        // Apply poison damage to the enemy at the end of player's turn
        if (targetEnemy.poisonCounter > 0) {
            const poisonDamage = targetEnemy.poisonCounter;
            targetEnemy.health -= poisonDamage;
            console.log(`Enemy takes ${poisonDamage} poison damage`);
            targetEnemy.poisonCounter++;
        }
        
        applyPoisonDamage(); // Apply poison damage at the end of the turn
        checkEnemyDefeat();
        if (gameState !== 'victory' && gameState !== 'duelVictory') {
            gameState = 'enemyTurn';
            updateButtonStates();
            drawGame();
            animateDamage();
            setTimeout(() => {
                handleEnemyTurn();
            }, 500);
        }
    }
}
  
        function playerSpecialAttack() {
    console.log("playerSpecialAttack function called");
    console.log("Current game state:", gameState);
    console.log("Special attack cooldown:", player.specialAttackCooldown);
    console.log("Player special skill:", player.specialSkill);
    
    if (gameState === 'playerTurn' && player.specialSkill && player.specialAttackCooldown === 0) {
        showPlayerTurnNotification();
        if (typeof player.specialSkill.use !== 'function') {
            console.error("Special skill 'use' is not a function!", player.specialSkill);
            return;
        }
        console.log("Using special skill:", player.specialSkill.name);
        
        try {
            const targetEnemy = enemies[selectedEnemyIndex];
            if (!targetEnemy) {
                console.error("No valid target enemy");
                return;
            }

            const result = player.specialSkill.use(player, targetEnemy);
            console.log("Skill use result:", result);

            if (result.damage > 0) {
                let finalDamage = result.damage;
                if (targetEnemy.exposed) {
                    finalDamage *= 2;
                    targetEnemy.exposed = false;
                    console.log("Target was exposed. Damage doubled to:", finalDamage);
                }
                targetEnemy.health -= finalDamage;
                // Update damage display
                damageDisplay.enemy.damage = finalDamage;
                damageDisplay.enemy.x = 725;
                damageDisplay.enemy.y = 150;
                damageDisplay.enemy.alpha = 1;
            }

            if (result.applyEffect) {
                result.applyEffect(targetEnemy);
            }

            displayMessage(result.effect);
            
            player.specialAttackCooldown = 3; // Set cooldown after using the skill
            console.log("Set special attack cooldown to:", player.specialAttackCooldown);
            
            applyPoisonDamage(); // Apply poison damage at the end of the turn
            checkEnemyDefeat();
            if (gameState !== 'victory') {
                gameState = 'enemyTurn';
                updateButtonStates();
                drawGame();
                animateDamage();
                setTimeout(() => {
                    handleEnemyTurn();
                }, 500);
            }
        } catch (error) {
            console.error("Error using special skill:", error);
        }
    } else {
        console.log("Cannot use special attack now");
        if (player.specialAttackCooldown > 0) {
            console.log("Special attack on cooldown:", player.specialAttackCooldown);
        }
        if (!player.specialSkill) {
            console.log("Player does not have a special skill");
        }
    }
}

        function checkEnemyDefeat() {
    if (enemies[selectedEnemyIndex].health <= 0) {
        let defeatedEnemyXP = 0;
        const isDuelEnemy = enemies[selectedEnemyIndex].class != null;

        if (isDuelEnemy) {
            // This is a duel enemy
            defeatedEnemyXP = 20; // Set a fixed XP for duel enemies, or calculate based on level
        } else {
            // This is a regular enemy
            const enemyType = enemyTypes.find(type => type.type === enemies[selectedEnemyIndex].type);
            defeatedEnemyXP = enemyType ? enemyType.xp : 0;
        }

        currentBattleExpGained += defeatedEnemyXP;
        const defeatedEnemy = enemies.splice(selectedEnemyIndex, 1)[0];
        resetDamageDisplay();
        selectedEnemyIndex = 0;

        if (enemies.length === 0) {
            if (isDuelEnemy) {
                gameState = 'duelVictory';
                clearNotification();
                showDuelVictoryScreen(defeatedEnemy);
            } else {
                gameState = 'victory';
                clearNotification();
                showVictoryScreen(currentBattleExpGained > defeatedEnemyXP); // Pass true if it was a double battle
            }
        }
    }
}

        function playerDefend() {
  
  if (player.specialAttackCooldown > 0) {
            player.specialAttackCooldown--;
            console.log("Special attack cooldown decreased to:", player.specialAttackCooldown);
        }
    if (gameState !== 'victory' && gameState !== 'duelVictory') {
        player.defending = true;
        //
        applyPoisonDamage(); // Apply poison damage at the end of the turn
        gameState = 'enemyTurn';
        showPlayerTurnNotification();
        updateButtonStates();
        drawGame();
        setTimeout(() => {
            handleEnemyTurn();
        }, 500);
    }
}

        function playerRetreat() {
    console.log("Player attempting to retreat");
     if (confirm("Are you sure you want to retreat? You will take damage from all enemies.")){
    showPlayerTurnNotification();

    // Calculate total damage from all enemies
    let totalDamage = 0;
    enemies.forEach(enemy => {
        let damage = Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage;
        totalDamage += damage;
    });

    // Apply damage to player
    player.health -= totalDamage;

    // Display retreat damage
    damageDisplay.player.damage = totalDamage;
    damageDisplay.player.x = 75;
    damageDisplay.player.y = 150;
    damageDisplay.player.alpha = 1;

    // Animate the damage
    drawGame();
    animateDamage();

    // Check if player survived the retreat
    setTimeout(() => {
        if (player.health <= 0) {
            console.log("Player died while retreating");
            gameState = 'defeat';
            showDefeatScreen();
        } else {
            console.log("Player successfully retreated");
            // Reset any battle-specific states here if needed
            player.defending = false;
            player.parry = false;
            player.burnedTurns = 0;
            player.poisonCounter = 0;
            player.blind = 0;
            player.shieldOfLight = 0;

            // Return to camp
            showCampScreen();
        }
    }, 500); // Wait for 1 second to show the damage before proceeding
  }
}

        function handleEnemyTurn() {
    showEnemyTurnNotification();
    updateButtonStates();
    const attackEnemies = (index) => {
        if (index >= enemies.length) {
            gameState = 'playerTurn';
            updateButtonStates();
            drawGame();
            resetDamageDisplay();
            return;
        }

        setTimeout(() => {
            let enemy = enemies[index];

            if (enemy.stunnedTurns > 0) {
                enemy.stunnedTurns--;
                attackEnemies(index + 1);
                return;
            }
			
			if (enemy.blind && Math.random() * 100 < enemy.blind) {
                displayMessage(`${enemy.type}'s attack missed due to being blinded!`);
                enemy.blind = Math.max(0, enemy.blind - 25);
                if (enemy.blind === 0) {
                    displayMessage(`${enemy.type} is no longer blinded.`);
                }
                attackEnemies(index + 1);
                return;
            }

            let damage = Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage;

            if (enemy.type === 'Poisonous Plant') {
    console.log("Poisonous Plant attack");
    if (Math.random() < 0.25) {
        console.log("Poisonous Plant poison attempt");
        if (!player.poisonCounter || player.poisonCounter === 0) {
            player.poisonCounter = 1;
            console.log("Player has been poisoned!");
            alert("You've been poisoned by the Poisonous Plant!");
        } else {
            console.log("Player already poisoned, poisonCounter:", player.poisonCounter);
        }
    } else {
        console.log("Poisonous Plant regular attack");
    }
}

             
            if (player.parry) {
            const parryDamage = Math.floor(Math.random() * (player.maxDamage - player.minDamage + 1)) + player.minDamage + 1;
            enemy.health -= parryDamage;
            damageDisplay.enemy.damage = parryDamage;
            damageDisplay.enemy.x = 725;
            damageDisplay.enemy.y = 150 + (index * 130);
            damageDisplay.enemy.alpha = 1;
            player.parry = false;
            displayMessage(`You parried the attack and dealt ${parryDamage} damage!`);
            console.log("Player parried the attack");
            damage = 0;  // The enemy's attack does no damage
        } else if (player.defending) {
            damage = Math.floor(damage / 2);
            player.defending = false;
        } else if (player.shieldOfLight > 0) {
            damage = Math.max(0, damage - 6);
            player.shieldOfLight--;
            if (player.shieldOfLight === 0) {
                player.maxDamage -= 2;
                player.health = Math.min(player.health + 6, player.maxHealth);
            }
        }

            player.health -= damage;

            damageDisplay.player.damage = damage;
            damageDisplay.player.x = 75;
            damageDisplay.player.y = 150 + (index * 30);
            damageDisplay.player.alpha = 1;
			
			if (enemy.blind) {
                enemy.blind = 0;
                displayMessage(`${enemy.type}'s attack hit! It is no longer blinded.`);
            }

            // Apply conditional damage to player
            if (player.burnedTurns > 0) {
                const burnDamage = Math.floor(Math.random() * 4) + 1;
                player.health -= burnDamage;
                console.log(`Player took ${burnDamage} burn damage`);
                player.burnedTurns--;
            }

            

            // Apply conditional damage after the enemy attacks
            let conditionalDamage = 0;

            if (enemy.burnedTurns > 0) {
                const burnDamage = Math.floor(Math.random() * 4) + 1;
                enemy.health -= burnDamage;
                damageDisplay.enemy.damage = burnDamage;
                damageDisplay.enemy.x = 725;
                damageDisplay.enemy.y = 150 + (index * 130);
                damageDisplay.enemy.alpha = 1;

                enemy.burnedTurns--;
            }

            if (enemy.poison) {
                const poisonDamage = enemy.poison;
                enemy.health -= poisonDamage;
                damageDisplay.enemy.damage = poisonDamage;
                damageDisplay.enemy.x = 725;
                damageDisplay.enemy.y = 150 + (index * 130);
                damageDisplay.enemy.alpha = 1;
            }

            if (conditionalDamage > 0) {
                damageDisplay.enemy.damage = conditionalDamage;
                damageDisplay.enemy.x = 725;
                damageDisplay.enemy.y = 150 + (index * 130);
                damageDisplay.enemy.alpha = 1;
            }

            if (enemy.health <= 0) {
                const defeatedEnemyXP = enemyTypes.find(type => type.type === enemy.type).xp;
                currentBattleExpGained += defeatedEnemyXP;
                enemies.splice(index, 1);
                if (enemies.length === 0) {
                    gameState = 'victory';
                    clearNotification();
                    showVictoryScreen();
                    return;
                }
            }

            if (player.health <= 0) {
                gameState = 'defeat';
                clearNotification();
                animateDamage();
                setTimeout(() => {
                    showDefeatScreen();
                }, 1000);
                return;
            }
            drawGame();
            animateDamage();
            setTimeout(() => {
                // Move to the next enemy, or end the turn if all enemies have acted
                attackEnemies(index + 1);
            }, 500);
        }, 500);
    };

    attackEnemies(0);
}

        function checkVictory() {
			if (enemies.length === 0) {
				gameState = 'victory';
				clearNotification();
				console.log("Checking victory. currentStoryContext:", currentStoryContext);
				showVictoryScreen(false, currentStoryContext);
			}
		}
		
		function showVictoryScreen(isDoubleBattle = false, currentStory = null) {
			const storyContext = currentStory || currentStoryContext;
			console.log("Showing victory screen. Story context:", storyContext);

			let goldEarned = Math.floor(Math.random() * 201) + 100;
			resetPurchasedItems(); // Reset purchased items for the new victory screen
			
			if (isDoubleBattle) {
				goldEarned += 100;
			}
			
			player.gold += goldEarned;
			let totalExpGained = currentBattleExpGained;
			if (player.expBooster) {
				totalExpGained *= 2;
				player.expBooster = false;
			}
			player.experience += totalExpGained;
			victoryExpGained = totalExpGained;
			
			if (player.experience >= player.xpToNextLevel) {
				checkBattleLevelUp();
			}
			
			updateVictoryScreenStats(storyContext === STORY_CHILLING_SCREAM);
			
			updateVictoryShopButtons();
			canvas.style.display = 'none';
			document.getElementById('gameButtons').style.display = 'none';
			document.getElementById('gameVictoryScreen').style.display = 'block';
			
			if (storyContext === STORY_CHILLING_SCREAM) {
				handleChillingScreamVictory();
			} else {
				showNormalVictoryButtons();
			}
			
			if (player.level >= 3 && !player.specialSkill) {
				document.getElementById('skillSelection').style.display = 'block';
				document.getElementById('continueJourneyButton').style.display = 'none';
				document.getElementById('returnToCampButton').style.display = 'none';
				showBattleSkillSelection();
			} else {
				document.getElementById('skillSelection').style.display = 'none';
			}
			
			currentBattleExpGained = 0;
			resetDamageDisplay();
			autoSave();
			updateLoadGameButton();
			ensureButtonVisibility();

			// Clear the story context
			currentStoryContext = null;
		}

			function handleChillingScreamVictory() {
				console.log("Handling Chilling Scream Victory");
				
				// Hide the continue journey and return to camp buttons
				document.getElementById('continueJourneyButton').style.display = 'none';
				document.getElementById('returnToCampButton').style.display = 'none';
				
				const rewardContainer = document.createElement('div');
				rewardContainer.id = 'chillingScreamRewardContainer';
				
				const rewardButton1 = document.createElement('button');
				rewardButton1.textContent = "Take the amulet";
				rewardButton1.onclick = function() {
					player.hpRegen = (player.hpRegen || 0) + 1;
					player.experience += 30;
					updateVictoryScreenStats();
					showNormalVictoryButtons();
					rewardContainer.remove();
				};
				
				const rewardButton2 = document.createElement('button');
				rewardButton2.textContent = "Take the gold and cookie";
				rewardButton2.onclick = function() {
					player.gold += 750;
					player.maxHealth += 4;
					player.health = player.maxHealth;
					player.experience += 30;
					updateVictoryScreenStats();
					showNormalVictoryButtons();
					rewardContainer.remove();
				};
				
				rewardContainer.appendChild(rewardButton1);
				rewardContainer.appendChild(rewardButton2);
				document.getElementById('gameVictoryScreen').appendChild(rewardContainer);
			}

function showNormalVictoryButtons() {
    console.log("Showing normal victory buttons");
    document.getElementById('continueJourneyButton').style.display = 'inline-block';
    document.getElementById('returnToCampButton').style.display = 'inline-block';
}


        
        function hideVictoryScreen() {
            document.getElementById('gameVictoryScreen').style.display = 'none';
            document.getElementById('gameVictoryScreen').style.display = 'none';
            document.getElementById('gameButtons').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'none';
        }
        

        function showDefeatScreen() {
    canvas.style.display = 'none';
    document.getElementById('gameButtons').style.display = 'none';
    

    // Reset all player status conditions
    player.poisonCounter = 0;
    player.burnedTurns = 0;
    player.blind = 0;
    player.shieldOfLight = 0;
    player.parry = false;
    player.defending = false;

    const defeatScreen = document.getElementById('gameDefeatScreen');
    defeatScreen.style.display = 'block';
    resetDamageDisplay();
    autoSave();
    updateLoadGameButton();
}

        function hideDefeatScreen() {
            const defeatScreen = document.getElementById('gameDefeatScreen');
            defeatScreen.style.display = 'none';
            canvas.style.display = 'block';
            document.getElementById('gameButtons').style.display = 'block';
        }

        function continueJourney() {
    console.log("Entering continueJourney function");
    hideAllScreens();
	victoryLevelUpMessage = '';
		
    if (gameState !== 'exploring') {
        console.warn(`Unexpected gameState in continueJourney: ${gameState}`);
        gameState = 'exploring';
    }
    
    const eventType = getEventType();
    console.log("Event type selected:", eventType);
    
    switch(eventType) {
        case 'duel':
            console.log("Starting duel event");
            startDuelEvent();
            break;
        case 'story':
            console.log("Starting story event");
            const storyEvent = Math.random();
            if (storyEvent < 0.25) {
                showStoryEvent1();
            } else if (storyEvent < 0.5) {
                showStoryEvent2();
            } else if (storyEvent < 0.75) {
                showStoryEvent3();
            } else {
                showStoryEvent4();
            }
            break;
        case 'battle':
            console.log("Starting battle");
            startBattle();
            break;
    }
}

        function returnToCamp() {
            hideVictoryScreen();
            document.getElementById('storyLevelUpMessage').style.display = 'none';
            document.getElementById('gameButtons').style.display = 'none';
            showCampScreen();
        }

        function showCampScreen() {
    if (!player.tents) {
        player.tents = 1;
    }
    if (!player.recruitedCharacters) {
        player.recruitedCharacters = [];
    }

    hideDuelEventScreen();
    hideVictoryScreen();
    hideStoryEventScreen();
    updateCampScreen();
    updateCampBankDisplay();
	updatePartyDisplay();
	logButtonStates();
    canvas.style.display = 'none';
    document.getElementById('gameButtons').style.display = 'none';
    
    const campScreen = document.getElementById('campScreen');
    campScreen.style.display = 'block';
    document.getElementById('storeGoldButton').onclick = storeGoldInCamp;
    
    updatePlayerTents();
    updateCommercialTents();
	updateTentButtons();
	updateTentButtonStates();
    
    // Update merchant tent button visibility
    const merchantTentButton = document.getElementById('merchantTentButton');
    if (merchantTentButton) {
        merchantTentButton.style.display = player.merchantTent ? 'none' : 'block';
    }
    
    // Ensure the continue journey button is visible
    document.getElementById('continueJourneyFromCampButton').style.display = 'block';
    
    // Move camp shop above continue journey button
    const campShop = document.getElementById('campShop');
    const continueButton = document.getElementById('continueJourneyFromCampButton');
    if (campShop && continueButton) {
        continueButton.parentNode.insertBefore(campShop, continueButton);
    }
    
    if (player.merchantTent) {
        showShopInCamp();
    }
    
    updateCampMessage();
    updateTentButtons();
    updateCampShopButtons();

    console.log("Camp screen updated. Player tents:", player.tents, "Recruited characters:", player.recruitedCharacters);
}

function createPartyMember(characterClass) {
    return {
        class: characterClass,
        specialSkills: {}, // This can be populated based on the class
        specialAttackCooldown: 0,
        health: 50,
        maxHealth: 50,
        minDamage: 1,
        maxDamage: 6,
        experience: 0,
        level: 1,
        xpToNextLevel: 20,
        defending: false,
		expBooster: false,
        specialSkillUnlocked: false,
        specialSkill: null,
        healthGain: 0,
        minDamageGain: 0,
        maxDamageGain: 0,
        poisonCounter: 0
        // You can add more properties as needed
    };
}
       
                
        function updatePlayerTents() {
    const playerTentsRow = document.getElementById('playerTentsRow');
    if (!playerTentsRow) {
        console.error("playerTentsRow not found");
        return;
    }

    // Clear existing tents
    playerTentsRow.innerHTML = '';

    // Create and update all tents
    for (let i = 1; i <= player.tents; i++) {
        const tentElement = createTentElement(i);
        playerTentsRow.appendChild(tentElement);

        if (i === 1) {
            updateTentContent(i, player.class);
        } else if (i <= player.recruitedCharacters.length + 1) {
            updateTentContent(i, player.recruitedCharacters[i-2].class);
        } else {
            updateTentContent(i, 'Empty');
        }
    }
}
        
        function updateCommercialTents() {
    const commercialTentsRow = document.getElementById('commercialTentsRow');
    if (!commercialTentsRow) {
        console.error("commercialTentsRow not found");
        return;
    }

    // Clear existing tents
    commercialTentsRow.innerHTML = '';
    
    if (player.merchantTent) {
        const merchantTentElement = createTentElement('Merchant');
        commercialTentsRow.appendChild(merchantTentElement);
        updateMerchantTentContent(merchantTentElement);
    }
}

function updateMerchantTentContent(tentElement) {
    tentElement.innerHTML = `
        <strong>Merchant Tent</strong><br>
        <span class="tent-occupant">Merchant</span><br>
        <button id="upgradesButton">Upgrades</button>
    `;
    
    // Use setTimeout to ensure the button is in the DOM before we try to access it
    setTimeout(() => {
        const upgradesButton = document.getElementById('upgradesButton');
        if (upgradesButton) {
            upgradesButton.onclick = showUpgradesPopup;
        } else {
            console.error('Upgrades button not found');
        }
    }, 0);
}

function showUpgradesPopup() {
    const popup = document.createElement('div');
    popup.id = 'upgradesPopup';
    popup.style.position = 'fixed';
    popup.style.left = '50%';
    popup.style.top = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.backgroundColor = 'white';
    popup.style.padding = '20px';
    popup.style.border = '2px solid black';
    popup.style.zIndex = '1000';

    popup.innerHTML = `
        <h2>Upgrades</h2>
        <div id="upgradeOptions"></div>
        <button id="closeUpgradesPopup">Close</button>
    `;

    document.body.appendChild(popup);
    document.getElementById('closeUpgradesPopup').onclick = closeUpgradesPopup;
    
    updateUpgradeOptions();
}

function closeUpgradesPopup() {
    const popup = document.getElementById('upgradesPopup');
    if (popup) {
        popup.remove();
    }
}

function updateUpgradeOptions() {
    const upgradeOptions = document.getElementById('upgradeOptions');
    if (!upgradeOptions) return;

    upgradeOptions.innerHTML = `
        <div>
            <button id="additionalPotionsUpgrade" 
                    ${merchantUpgrades.additionalPotions ? 'disabled' : ''}
                    onclick="purchaseUpgrade('additionalPotions', 500)">
                ${merchantUpgrades.additionalPotions ? 'Additional Potions (Purchased)' : 'Additional Potions (500 Gold)'}
            </button>
            <p>Allows purchasing two healing potions before sold out</p>
        </div>
        <div>
            <button id="flexibleCurrencyUpgrade" 
                    ${merchantUpgrades.flexibleCurrency ? 'disabled' : ''}
                    onclick="purchaseUpgrade('flexibleCurrency', 700)">
                ${merchantUpgrades.flexibleCurrency ? 'Flexible Currency (Purchased)' : 'Flexible Currency (700 Gold)'}
            </button>
            <p>Allows using Camp Bank for purchases</p>
        </div>
        <div>
            <button id="increasedPotionPotencyUpgrade" 
                    ${merchantUpgrades.increasedPotionPotency ? 'disabled' : ''}
                    onclick="purchaseUpgrade('increasedPotionPotency', 1250)">
                ${merchantUpgrades.increasedPotionPotency ? 'Increased Potion Potency (Purchased)' : 'Increased Potion Potency (1250 Gold)'}
            </button>
            <p>Doubles the healing effect of HP potions</p>
        </div>
        <div>
            <button id="massProducedAntidoteUpgrade" 
                    ${merchantUpgrades.massProducedAntidote ? 'disabled' : ''}
                    onclick="purchaseUpgrade('massProducedAntidote', 900)">
                ${merchantUpgrades.massProducedAntidote ? 'Mass Produced Antidote (Purchased)' : 'Mass Produced Antidote (900 Gold)'}
            </button>
            <p>Reduces the price of antidotes from 300 to 150 gold</p>
        </div>
        <div>
            <button id="improvedLotusHarvestingUpgrade" 
                    ${merchantUpgrades.improvedLotusHarvesting ? 'disabled' : ''}
                    onclick="purchaseUpgrade('improvedLotusHarvesting', 1500)">
                ${merchantUpgrades.improvedLotusHarvesting ? 'Improved Lotus Harvesting (Purchased)' : 'Improved Lotus Harvesting (1500 Gold)'}
            </button>
            <p>Doubles the XP gained from Lotus of Experience (20 XP instead of 10 XP)</p>
        </div>
    `;
}

		function purchaseUpgrade(upgrade, cost) {
			if (player.campBank < cost) {
				alert("Not enough gold in the Camp Bank!");
				return;
			}

			player.campBank -= cost;
			merchantUpgrades[upgrade] = true;
			updateUpgradeOptions();
			updateCampMessage();
			
			let upgradeMessage = `You have purchased the ${upgrade} upgrade!`;
			switch(upgrade) {
				case 'increasedPotionPotency':
					upgradeMessage += " HP potions will now heal twice as much.";
					break;
				case 'massProducedAntidote':
					upgradeMessage += " Antidotes now cost 150 gold instead of 300 gold.";
					break;
				case 'improvedLotusHarvesting':
					upgradeMessage += " Lotus of Experience will now grant 20 XP instead of 10 XP.";
					break;
			}
			
			alert(upgradeMessage);
			
			// If in camp, update the shop to reflect any changes
			if (document.getElementById('campShop')) {
				showShopInCamp();
			}
		}
        
       function createTentElement(number) {
    const tent = document.createElement('div');
    tent.id = number === 'Merchant' ? 'merchantTent' : `tent${number}`;
    tent.className = 'tent';
    tent.innerHTML = `
        <strong>${number === 'Merchant' ? 'Merchant Tent' : `Tent ${number}`}</strong><br>
        <span class="tent-occupant">Empty</span>
    `;
    // Add any CSS styles here to make it look like a square
    tent.style.width = '100px';
    tent.style.height = '100px';
    tent.style.border = '2px solid black';
    tent.style.display = 'inline-block';
    tent.style.margin = '5px';
    tent.style.padding = '5px';
    return tent;
}

function updatePartyDisplay() {
    console.log("Current party:", player.party);
    // Here you can add code to update any UI elements that show the current party
    // For example, updating a party member list in the camp screen
}
        
        function showShopInCamp() {
    if (player.merchantTent) {
        const existingShop = document.getElementById('campShop');
        if (existingShop) {
            existingShop.remove();
        }
        const shopDiv = document.createElement('div');
        shopDiv.id = 'campShop';
        shopDiv.innerHTML = `
            <h2 style="text-align: center;">Merchant Shop</h2>
            <div id="campMessage" style="margin-bottom: 20px; padding: 10px; border-radius: 5px; text-align: center;">
                HP: ${player.health}/${player.maxHealth}<br>
                Min Damage: ${player.minDamage}<br>
                Max Damage: ${player.maxDamage}<br>
                XP: ${player.experience}/${player.xpToNextLevel}<br>
            </div>
            <div class="shop-items" style="display: flex; flex-direction: column; align-items: center;">
                ${createShopItem('campHealingPotionButton', 'Buy Healing Potion', 100, 'Heal 25 HP')}
                ${createShopItem('campExpBoosterButton', 'Buy EXP Booster', 200, 'Double the next XP gained')}
                ${createShopItem('campAntidoteButton', 'Buy Antidote', 300, 'Heals poison')}
                ${createShopItem('campLotusButton', 'Buy Lotus of Experience', 500, 'Grants 10 XP')}
                ${createShopItem('campRedPillButton', 'Buy Red Pill', 1000, '+1 Min Damage')}
            </div>
        `;
        shopDiv.style.textAlign = 'center';
        const continueButton = document.getElementById('continueJourneyFromCampButton');
        continueButton.parentNode.insertBefore(shopDiv, continueButton);
        updateCampShopButtons();
    }
}
        
        function createShopItem(id, name, gold, description) {
    const itemKey = id.replace('camp', '').replace('Button', '').toLowerCase();
    const isPurchased = player.purchasedItems && player.purchasedItems[itemKey];
    const healAmount = merchantUpgrades.increasedPotionPotency ? 50 : 25;
    let updatedDescription = description;
    let updatedGold = gold;

    if (itemKey === 'healingpotion') {
        updatedDescription = `Heal ${healAmount} HP`;
    } else if (itemKey === 'antidote' && merchantUpgrades.massProducedAntidote) {
        updatedGold = 150;
    } else if (itemKey === 'lotus') {
        updatedDescription = `Grants ${merchantUpgrades.improvedLotusHarvesting ? 20 : 10} XP`;
    }
    
    return `
        <div class="shop-item" style="margin-bottom: 10px; width: 100%; max-width: 300px;">
            <button id="${id}" ${isPurchased ? 'disabled' : ''} style="width: 100%;">
                <div class="button-content">
                    <span class="item-name">${isPurchased ? 'Sold Out' : name}</span>
                    ${!isPurchased ? `<span class="gold-amount">${updatedGold} Gold</span>` : ''}
                </div>
            </button>
            <span class="item-description" style="display: block; margin-top: 5px;">${updatedDescription}</span>
        </div>
    `;
}
        
			function buyVictoryItem(item, cost, itemName) {
				const purchaseResult = handleFlexiblePurchase(item, cost, itemName, true);
				if (!purchaseResult.canPurchase) {
					return;
				}

				if (item === 'healingPotion') {
					if (!currentVictoryScreenPurchases[item]) {
						currentVictoryScreenPurchases[item] = 0;
					}
					if (currentVictoryScreenPurchases[item] >= (merchantUpgrades.additionalPotions ? 2 : 1)) {
						alert("Healing Potions are sold out!");
						return;
					}
					currentVictoryScreenPurchases[item]++;
				} else if (currentVictoryScreenPurchases[item]) {
					alert(`${itemName} is already sold out!`);
					return;
				} else {
					currentVictoryScreenPurchases[item] = true;
				}

				if (purchaseResult.usingCampBank) {
					player.campBank -= cost;
				} else {
					player.gold -= cost;
				}

				const effectMessage = applyItemEffect(item);
				updateGoldMessage();
				updateVictoryScreenStats();
				updateVictoryShopButtons();
				alert(`You bought ${itemName} for ${cost} gold ${purchaseResult.usingCampBank ? 'from your Camp Bank' : ''}. ${effectMessage}`);
			}

        
        function updateCampMessage() {
            const campMessageElement = document.getElementById('campMessage');
            if (campMessageElement) {
                campMessageElement.innerHTML = `
                    Current Gold: ${player.gold}<br>
                    Camp Bank: ${player.campBank} Gold<br>
                    Tents: ${player.tents}<br>
                    HP: ${player.health}/${player.maxHealth}
                `;
            }
        }
        
        function updateTentButtons() {
    const tentWords = ['second', 'third', 'fourth', 'fifth'];
    tentWords.forEach((tentWord, index) => {
        const button = document.getElementById(`${tentWord}TentButton`);
        if (button) {
            if (index + 2 === player.tents + 1 && player.tents < 5) {
                button.style.display = 'block';
            } else if (button.style.display === 'block') {
                button.style.display = 'none';
            }
            // If the button is already hidden, we don't change its display property
        }
    });
}

function logButtonStates() {
    ['second', 'third', 'fourth', 'fifth'].forEach(tentWord => {
        const button = document.getElementById(`${tentWord}TentButton`);
        console.log(`${tentWord} tent button display: ${button ? button.style.display : 'element not found'}`);
    });
}

        function getEventType() {
            const eventRoll = Math.random();
            
            if (duelEventsUnlocked) {
                // Duel events unlocked
                if (eventRoll < 0.70) {
                    return 'battle';
                } else if (eventRoll < 0.85) {
                    return 'story';
                } else {
                    return 'duel';
                }
            } else {
                // Duel events locked
                if (eventRoll < 0.85) {
                    return 'battle';
                } else {
                    return 'story';
                }
            }
        }
    
        function hideCampScreen() {
			document.getElementById('campScreen').style.display = 'none';
			document.getElementById('gameVictoryScreen').style.display = 'none';
      document.getElementById('gameButtons').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'none';
		}

        function storeGoldInCamp() {
    if (player.gold > 0) {
        player.campBank += player.gold;
        player.gold = 0;
        updateCampBankDisplay();
        updateTentButtonStates(); // Add this line
        updateCampMessage("All gold stored in Camp Bank!");
    } else {
        updateCampMessage("You have no gold to store.");
    }
}

        function hideVictoryScreen() {
			document.getElementById('gameVictoryScreen').style.display = 'none';
			document.getElementById('gameVictoryScreen').style.display = 'none';
      document.getElementById('gameButtons').style.display = 'none';
      document.getElementById('gameCanvas').style.display = 'none';
		}
		
		    function removeAllEventListeners(element) {
    const newElement = element.cloneNode(true);
    element.parentNode.replaceChild(newElement, element);
    return newElement;
}

        function updateVictoryShopButtons() {
    const buttons = [
        { id: 'healingPotionButton', item: 'healingPotion', cost: 100, name: 'Healing Potion' },
        { id: 'expBoosterButton', item: 'expBooster', cost: 200, name: 'EXP Booster' },
        { id: 'antidoteButton', item: 'antidote', cost: merchantUpgrades.massProducedAntidote ? 150 : 300, name: 'Antidote' },
        { id: 'lotusButton', item: 'lotus', cost: 500, name: 'Lotus of Experience' },
        { id: 'redPillButton', item: 'redPill', cost: 1000, name: 'Red Pill' }
    ];

    buttons.forEach(button => {
        const element = document.getElementById(button.id);
        if (element) {
            const isPotionSoldOut = button.item === 'healingPotion' && 
                                    currentVictoryScreenPurchases[button.item] >= (merchantUpgrades.additionalPotions ? 2 : 1);
            const isOtherItemSoldOut = button.item !== 'healingPotion' && currentVictoryScreenPurchases[button.item];

            element.disabled = isPotionSoldOut || isOtherItemSoldOut;
            element.innerHTML = `
                <div class="button-content">
                    <span class="item-name">${isPotionSoldOut || isOtherItemSoldOut ? 'Sold Out' : button.name}</span>
                    ${!(isPotionSoldOut || isOtherItemSoldOut) ? `<span class="gold-amount">${button.cost} Gold</span>` : ''}
                </div>
            `;
            if (!(isPotionSoldOut || isOtherItemSoldOut)) {
                element.onclick = () => buyVictoryItem(button.item, button.cost, button.name);
            }
        }
    });
}

        function updateCampShopButtons() {
    const buttons = [
        { id: 'campHealingPotionButton', item: 'healingPotion', cost: 100, name: 'Healing Potion', description: 'Heal 25 HP' },
        { id: 'campExpBoosterButton', item: 'expBooster', cost: 200, name: 'EXP Booster', description: 'Double the next XP gained' },
        { id: 'campAntidoteButton', item: 'antidote', cost: merchantUpgrades.massProducedAntidote ? 150 : 300, name: 'Antidote', description: 'Heals poison' },
        { id: 'campLotusButton', item: 'lotus', cost: 500, name: 'Lotus of Experience', description: 'Grants 10 XP' },
        { id: 'campRedPillButton', item: 'redPill', cost: 1000, name: 'Red Pill', description: '+1 Min Damage' }
    ];

    buttons.forEach(button => {
        const element = document.getElementById(button.id);
        if (element) {
            const isPotionSoldOut = button.item === 'healingPotion' && 
                                    player.purchasedItems[button.item] >= (merchantUpgrades.additionalPotions ? 2 : 1);
            const isOtherItemSoldOut = button.item !== 'healingPotion' && player.purchasedItems[button.item];
            const isHPFull = button.item === 'healingPotion' && player.health >= player.maxHealth;

            if (isPotionSoldOut || isOtherItemSoldOut) {
                element.disabled = true;
                element.innerHTML = '<div class="button-content"><span class="item-name">Sold Out</span></div>';
            } else if (isHPFull) {
                element.disabled = true;
                element.innerHTML = '<div class="button-content"><span class="item-name">HP Full</span></div>';
            } else {
                element.disabled = false;
                element.innerHTML = `
                    <div class="button-content">
                        <span class="item-name">Buy ${button.name}</span>
                        <span class="gold-amount">${button.cost} Gold</span>
                    </div>
                `;
                element.onclick = () => buyItemInCamp(button.item, button.cost, button.name);
            }
        }
    });
}

		function handleFlexiblePurchase(item, cost, itemName, isVictoryScreen = false) {
			if (player.gold >= cost) {
				// If player has enough gold, proceed with normal purchase
				return { canPurchase: true, usingCampBank: false };
			} else if (merchantUpgrades.flexibleCurrency && player.campBank >= cost) {
				// If player doesn't have enough gold but has the upgrade and enough in camp bank
				const useBank = confirm(`You don't have enough gold (${player.gold}/${cost}), but you have enough in your Camp Bank (${player.campBank}). Would you like to use your Camp Bank for this purchase?`);
				if (useBank) {
					return { canPurchase: true, usingCampBank: true };
				}
			}
			// If player can't or doesn't want to make the purchase
			alert("Not enough gold!");
			return { canPurchase: false, usingCampBank: false };
		}

		function buyItemInCamp(item, cost, itemName) {
			const button = document.getElementById(`camp${item.charAt(0).toUpperCase() + item.slice(1)}Button`);
			if (button) {
				button.disabled = true;
			}

			const purchaseResult = handleFlexiblePurchase(item, cost, itemName);
			if (!purchaseResult.canPurchase) {
				if (button) button.disabled = false;
				return;
			}

			if (item === 'healingPotion') {
				if (player.health >= player.maxHealth) {
					alert("Your HP is full! You can't buy a Healing Potion right now.");
					if (button) button.disabled = false;
					return;
				}

				if (!player.purchasedItems[item]) {
					player.purchasedItems[item] = 0;
				}
				if (player.purchasedItems[item] >= (merchantUpgrades.additionalPotions ? 2 : 1)) {
					alert("Healing Potions are sold out!");
					if (button) button.disabled = false;
					return;
				}
				player.purchasedItems[item]++;
			} else if (player.purchasedItems[item]) {
				alert(`${itemName} is already sold out!`);
				if (button) button.disabled = false;
				return;
			} else {
				player.purchasedItems[item] = true;
			}

			if (purchaseResult.usingCampBank) {
				player.campBank -= cost;
			} else {
				player.gold -= cost;
			}

			const effectMessage = applyItemEffect(item);
			updateCampMessage();
			updateCampShopButtons();
			alert(`You bought ${itemName} for ${cost} gold ${purchaseResult.usingCampBank ? 'from your Camp Bank' : ''}. ${effectMessage}`);
			
			// If the player leveled up, we need to update the UI
			if (item === 'lotus') {
				updatePlayerStats();
			}
		}
		
		function updatePlayerStats() {
			// Update any UI elements that display player stats
			// For example:
			document.getElementById('playerLevel').textContent = player.level;
			document.getElementById('playerHealth').textContent = `${player.health}/${player.maxHealth}`;
			document.getElementById('playerExperience').textContent = `${player.experience}/${player.xpToNextLevel}`;
			// Add any other stats that need updating
		}
        
        function applyItemEffect(item) {
			switch(item) {
				case 'healingPotion':
					const baseHealAmount = 25;
					const healAmount = merchantUpgrades.increasedPotionPotency ? baseHealAmount * 2 : baseHealAmount;
					const oldHealth = player.health;
					player.health = Math.min(player.health + healAmount, player.maxHealth);
					const actualHeal = player.health - oldHealth;
					return `You've been healed for ${actualHeal} HP.`;
				case 'expBooster':
					player.expBooster = true;
					return "Your next XP gain will be doubled.";
				case 'antidote':
					player.poisonCounter = 0;
					return "You've been cured of poison.";
				case 'lotus':
					const lotusXP = merchantUpgrades.improvedLotusHarvesting ? 20 : 10;
					player.experience += lotusXP;
					const leveledUp = checkLevelUp();
					return `You gained ${lotusXP} XP.${leveledUp ? ' You leveled up!' : ''}`;
				case 'redPill':
					player.minDamage += 1;
					return "Your minimum damage has increased by 1.";
				default:
					return "";
			}
		}
        
        function buyHealingPotion() {
            buyItem('Healing Potion', 100, () => {
                player.health = Math.min(player.health + 25, player.maxHealth);
            });
        }
        
        function buyExpBooster() {
            buyItem('EXP Booster', 200, () => {
                player.expBooster = true;
            });
        }
        
        function buyAntidote() {
            buyItem('Antidote', 300, () => {
                player.poisonCounter = 0;
            });
        }
        
        function buyLotusOfExperience() {
            buyItem('Lotus of Experience', 500, () => {
                player.experience += 10;
                checkBattleLevelUp();
            });
        }
        
        function buyRedPill() {
            buyItem('Red Pill', 1000, () => {
                player.minDamage += 1;
            });
        }

        function checkStoryLevelUp() {
    let leveledUp = false;
    while (player.experience >= player.xpToNextLevel) {
        leveledUp = true;
        player.level++;
        player.experience -= player.xpToNextLevel;
        player.xpToNextLevel += 20;

        player.healthGain = Math.floor(Math.random() * 5) + 3;
        player.maxHealth += player.healthGain;
        player.health = player.maxHealth;

        player.minDamageGain = 0;
        player.maxDamageGain = 0;
        if (Math.random() <= 0.25) {
            player.minDamage += 1;
            player.minDamageGain = 1;
        }

        const maxDamageIncreaseRoll = Math.random() * 100;
        if (maxDamageIncreaseRoll <= 60) {
            player.maxDamage += 1;
            player.maxDamageGain = 1;
        } else if (maxDamageIncreaseRoll <= 90) {
            player.maxDamage += 2;
            player.maxDamageGain = 2;
        } else {
            player.maxDamage += 3;
            player.maxDamageGain = 3;
        }

        let levelUpMessage = `You leveled up! Gained ${player.healthGain} health, +${player.minDamageGain} min damage, +${player.maxDamageGain} max damage.`;

        // Show special skill selection when reaching level 3
        if (player.level === 3 && !player.specialSkillUnlocked) {
            console.log("Triggering skill selection for " + player.class);
            player.specialSkillUnlocked = true;
            showStorySkillSelection();
            updateStoryScreenStats();
            showLevelUpMessage(levelUpMessage);
            return; // Exit the function to prevent further level-ups until skill is chosen
        }

        updateStoryScreenStats();
        showLevelUpMessage(levelUpMessage);
    }
    
    if (leveledUp && player.level >= 3 && player.specialSkill) {
        showFinalContinueButton(); // Only show continue button if a skill has been selected
    }
}

        function checkBattleLevelUp() {
    let leveledUp = false;
    while (player.experience >= player.xpToNextLevel) {
        leveledUp = true;
        player.level++;
        player.experience -= player.xpToNextLevel;
        player.xpToNextLevel += 20;

        player.healthGain = Math.floor(Math.random() * 5) + 3;
        player.maxHealth += player.healthGain;
        player.health = player.maxHealth;

        player.minDamageGain = 0;
        player.maxDamageGain = 0;
        if (Math.random() <= 0.25) {
            player.minDamage += 1;
            player.minDamageGain = 1;
        }

        const maxDamageIncreaseRoll = Math.random() * 100;
        if (maxDamageIncreaseRoll <= 60) {
            player.maxDamage += 1;
            player.maxDamageGain = 1;
        } else if (maxDamageIncreaseRoll <= 90) {
            player.maxDamage += 2;
            player.maxDamageGain = 2;
        } else {
            player.maxDamage += 3;
            player.maxDamageGain = 3;
        }

        let levelUpMessage = `You leveled up! Gained ${player.healthGain} health, +${player.minDamageGain} min damage, +${player.maxDamageGain} max damage.`;
        victoryLevelUpMessage += levelUpMessage + '<br>';

        // Show special skill selection when reaching level 3
        if (player.level === 3 && !player.specialSkillUnlocked) {
			console.log("Player reached level 3, setting up class skills");
			setupClassSkills();
			player.specialSkillUnlocked = true;
			showBattleSkillSelection();
			break; // Exit the loop after showing skill selection
		}
    }
    return leveledUp;
}

function checkLevelUp() {
    let leveledUp = false;
    while (player.experience >= player.xpToNextLevel) {
        leveledUp = true;
        player.level++;
        player.experience -= player.xpToNextLevel;
        player.xpToNextLevel += 20;

        player.healthGain = Math.floor(Math.random() * 5) + 3;
        player.maxHealth += player.healthGain;
        player.health = player.maxHealth;

        player.minDamageGain = 0;
        player.maxDamageGain = 0;
        if (Math.random() <= 0.25) {
            player.minDamage += 1;
            player.minDamageGain = 1;
        }

        const maxDamageIncreaseRoll = Math.random() * 100;
        if (maxDamageIncreaseRoll <= 60) {
            player.maxDamage += 1;
            player.maxDamageGain = 1;
        } else if (maxDamageIncreaseRoll <= 90) {
            player.maxDamage += 2;
            player.maxDamageGain = 2;
        } else {
            player.maxDamage += 3;
            player.maxDamageGain = 3;
        }

        let levelUpMessage = `You leveled up! Gained ${player.healthGain} health, +${player.minDamageGain} min damage, +${player.maxDamageGain} max damage.`;
        alert(levelUpMessage);

        // Show special skill selection when reaching level 3
        if (player.level === 3 && !player.specialSkillUnlocked) {
            console.log("Player reached level 3, setting up class skills");
            setupClassSkills();
            player.specialSkillUnlocked = true;
            showBattleSkillSelection();
            break; // Exit the loop after showing skill selection
        }
    }
    return leveledUp;
}

        function updateGoldMessage() {
            document.getElementById('goldMessage').innerHTML = `Current Gold: ${player.gold}<br><br>Camp Bank: ${player.campBank} Gold`;
        }

        function updateVictoryScreenStats(includeStoryConclusion = false) {
			let victoryMessage = `You earned ${victoryExpGained} XP for winning this battle.<br>`;
			if (victoryLevelUpMessage) {
				victoryMessage += `${victoryLevelUpMessage}<br>`;
			}
			victoryMessage += `Current Stats:<br>
			Health: ${player.health}/${player.maxHealth}<br>
			Min Damage: ${player.minDamage}<br>
			Max Damage: ${player.maxDamage}<br>
			XP: ${player.experience}/${player.xpToNextLevel}`;

			if (includeStoryConclusion && currentStoryContext === STORY_CHILLING_SCREAM) {
				let storyConclusion = "You walk up to the terrified woman and help her stand. She starts crying and thanks you for helping her. She says she would have died if not for you. She doesn't have much on her, but she offers you a strange amulet or all her gold and a Premium HP Cookie.";
				victoryMessage += `<br><br>${storyConclusion}`;
			}

			document.getElementById('victoryMessage').innerHTML = victoryMessage;
			document.getElementById('goldMessage').innerHTML = `Current Gold: ${player.gold}<br><br>Camp Bank: ${player.campBank} Gold`;
		}

        function clearNotification() {
            const notificationElement = document.getElementById('notificationText');
            notificationElement.textContent = '';
        }
		
		function resetStoryChoices() {
			document.getElementById('storyChoice1Button').style.display = 'inline-block';
			document.getElementById('storyChoice2Button').style.display = 'inline-block';
			document.getElementById('storyChoice3Button').style.display = 'inline-block';
		}

        function showStoryEvent1() {
            console.log("Entering showStoryEvent1");
            inStoryEvent = true;
            ensureButtonVisibility();
            currentStory = STORY_OLD_MAN;
            document.getElementById('storyLevelUpMessage').style.display = 'none';
            document.getElementById('storyLevelUpMessage').innerHTML = '';
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('gameButtons').style.display = 'none';
            document.getElementById('storyEventScreen').style.display = 'block';
            document.getElementById('storyText').innerHTML = "You encounter an old man on the road. He asks if you can spare 100 gold for some food and a warm bed.";

			resetStoryChoices();  // Reset all choice buttons

            document.getElementById('storyChoice1Button').textContent = "Give the old man 100 gold";
            document.getElementById('storyChoice2Button').textContent = "Ask what he is doing on the road";
            document.getElementById('storyChoice3Button').textContent = "Ignore him and keep walking";

            // Remove previous event listeners before adding new ones
            removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

            document.getElementById('storyChoice1Button').addEventListener('click', handleOldManChoice1);
            document.getElementById('storyChoice2Button').addEventListener('click', handleOldManChoice2);
            document.getElementById('storyChoice3Button').addEventListener('click', handleOldManChoice3);

            document.getElementById('storyChoices').style.display = 'block';
            document.getElementById('continueJourneyFromStoryButton').style.display = 'none';
            document.getElementById('continueToBattleButton').style.display = 'none'; // Ensure the button is hidden initially
            document.getElementById('storyStats').style.display = 'none'; // Hide stats initially
        }

        function handleOldManChoice1() {
            console.log("Executing handleOldManChoice1");
            if (currentStory !== STORY_OLD_MAN) return;
            if (player.gold >= 100) {
                player.gold -= 100;
                player.minDamage += 1;
                player.maxDamage += 1;
                let xpGained = player.expBooster ? 20 : 10; // Double XP if booster is active
                player.experience += xpGained;
                document.getElementById('storyText').innerHTML = `The old man teaches you to be a better fighter. You gain +1 min damage, +1 max damage, and ${xpGained} XP.`;
                checkStoryLevelUp();
                player.expBooster = false; // Reset the XP booster after use

                // Show level-up message if player leveled up
                if (player.experience >= player.xpToNextLevel) {
                    showLevelUpMessage();
                }
            } else {
                document.getElementById('storyText').innerHTML = "You don't have enough gold to give.";
            }
            showFinalContinueButton(); // Show final continue button and update stats
        }

        function handleOldManChoice2() {
            console.log("Executing handleOldManChoice2");
            if (currentStory !== STORY_OLD_MAN) return;
            document.getElementById('storyText').innerHTML = "The old man explains that he is going to visit his family but since age has caught up to him, the trip is slow and he has exhausted all the gold he had.";

            document.getElementById('storyChoice1Button').textContent = "Give him 100 gold";
            document.getElementById('storyChoice2Button').textContent = "Give him 200 gold";
            document.getElementById('storyChoice3Button').textContent = "Walk away and continue the journey";

            // Remove previous event listeners before adding new ones
            removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

            document.getElementById('storyChoice1Button').addEventListener('click', handleOldManChoice1_2);
            document.getElementById('storyChoice2Button').addEventListener('click', handleOldManChoice2_2);
            document.getElementById('storyChoice3Button').addEventListener('click', handleOldManChoice3_2);

            document.getElementById('storyChoices').style.display = 'block';
        }

        function handleOldManChoice1_2() {
            console.log("Executing handleOldManChoice1_2");
            if (currentStory !== STORY_OLD_MAN) return;
            if (player.gold >= 100) {
                player.gold -= 100;
                player.minDamage += 1;
                player.maxDamage += 1;
                let xpGained = player.expBooster ? 20 : 10; // Double XP if booster is active
                player.experience += xpGained;
                document.getElementById('storyText').innerHTML = `The old man teaches you to be a better fighter. You gain +1 min damage, +1 max damage, and ${xpGained} XP.`;
                checkStoryLevelUp();
                player.expBooster = false; // Reset the XP booster after use

                // Show level-up message if player leveled up
                if (player.experience >= player.xpToNextLevel) {
                    showLevelUpMessage();
                }
            } else {
                document.getElementById('storyText').innerHTML = "You don't have enough gold to give.";
            }
            showFinalContinueButton(); // Show final continue button and update stats
        }

        function handleOldManChoice2_2() {
            console.log("Executing handleOldManChoice2_2");
            if (currentStory !== STORY_OLD_MAN) return;
            if (player.gold >= 200) {
                player.gold -= 200;
                player.minDamage += 1;
                player.maxDamage += 2;
                let xpGained = player.expBooster ? 20 : 10; // Double XP if booster is active
                player.experience += xpGained;
                document.getElementById('storyText').innerHTML = `The old man is deeply grateful and teaches you advanced combat techniques. You gain +1 min damage, +2 max damage, and ${xpGained} XP.`;
                checkStoryLevelUp();
                player.expBooster = false; // Reset the XP booster after use

                // Show level-up message if player leveled up
                if (player.experience >= player.xpToNextLevel) {
                    showLevelUpMessage();
                }
            } else {
                document.getElementById('storyText').innerHTML = "You don't have enough gold to give.";
            }
            showFinalContinueButton(); // Show final continue button and update stats
        }

        function handleOldManChoice3() {
            console.log("Executing handleOldManChoice3");
            if (currentStory !== STORY_OLD_MAN) return;
            document.getElementById('storyText').innerHTML = "You ignore the old man and keep walking.";
            showFinalContinueButton(); // Show final continue button and update stats
        }

        function handleOldManChoice3_2() {
            console.log("Executing handleOldManChoice3_2");
            if (currentStory !== STORY_OLD_MAN) return;
            document.getElementById('storyText').innerHTML = "You walk away and continue your journey.";
            showFinalContinueButton(); // Show final continue button and update stats
        }

        function showStoryEvent2() {
            console.log("Entering showStoryEvent2");
            inStoryEvent = true;
            ensureButtonVisibility();
            currentStory = STORY_TREANT;
            document.getElementById('storyLevelUpMessage').style.display = 'none';
            document.getElementById('storyLevelUpMessage').innerHTML = '';
            document.getElementById('gameCanvas').style.display = 'none';
            document.getElementById('gameButtons').style.display = 'none';
            document.getElementById('storyEventScreen').style.display = 'block';
            document.getElementById('storyText').innerHTML = "You find a tree that seems to be murmuring to itself. You get close to the tree and have 3 options.";

			resetStoryChoices();  // Reset all choice buttons

            document.getElementById('storyChoice1Button').textContent = "Poke the tree with your weapon";
            document.getElementById('storyChoice2Button').textContent = "Ask if it's alright";
            document.getElementById('storyChoice3Button').textContent = "Leave right away";

            // Remove previous event listeners before adding new ones
            removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

            document.getElementById('storyChoice1Button').addEventListener('click', handleTreePoke1);
            document.getElementById('storyChoice2Button').addEventListener('click', handleTreeAsk);
            document.getElementById('storyChoice3Button').addEventListener('click', handleTreeLeave);

            document.getElementById('storyChoices').style.display = 'block';
            document.getElementById('continueJourneyFromStoryButton').style.display = 'none';
            document.getElementById('continueToBattleButton').style.display = 'none'; // Ensure the button is hidden initially
            document.getElementById('storyStats').style.display = 'none'; // Hide stats initially
        }

        function handleTreePoke1() {
            console.log("Executing handleTreePoke1");
            if (currentStory !== STORY_TREANT) return;
            document.getElementById('storyText').innerHTML = "The tree asks why you are bothering it, as it is having trouble sleeping. It would appreciate if you could leave it alone.";

            document.getElementById('storyChoice1Button').textContent = "Poke it again";
            document.getElementById('storyChoice2Button').textContent = "Ask why it needs to sleep";
            document.getElementById('storyChoice3Button').textContent = "Walk away";

            // Remove previous event listeners before adding new ones
            removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

            document.getElementById('storyChoice1Button').addEventListener('click', handleTreePoke2);
            document.getElementById('storyChoice2Button').addEventListener('click', handleTreeAsk2);
            document.getElementById('storyChoice3Button').addEventListener('click', handleTreeLeave);

            document.getElementById('storyChoices').style.display = 'block';
            document.getElementById('continueJourneyFromStoryButton').style.display = 'none';
            document.getElementById('continueToBattleButton').style.display = 'none';
        }

        function handleTreePoke2() {
            console.log("Executing handleTreePoke2");
            if (currentStory !== STORY_TREANT) return;
            document.getElementById('storyText').innerHTML = "The tree says it wishes to be left alone and does not want to be hurt or hurt anyone but will defend itself to rest.";

            document.getElementById('storyChoice1Button').textContent = "Poke it a third time";
            document.getElementById('storyChoice2Button').textContent = "Ask why it needs to sleep";
            document.getElementById('storyChoice3Button').textContent = "Walk away";

            // Remove previous event listeners before adding new ones
            removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

            document.getElementById('storyChoice1Button').addEventListener('click', handleTreePoke3);
            document.getElementById('storyChoice2Button').addEventListener('click', handleTreeAsk2);
            document.getElementById('storyChoice3Button').addEventListener('click', handleTreeLeave);

            document.getElementById('storyChoices').style.display = 'block';
            document.getElementById('continueJourneyFromStoryButton').style.display = 'none';
            document.getElementById('continueToBattleButton').style.display = 'none';
        }

        function handleTreePoke3() {
            console.log("Executing handleTreePoke3");
            if (currentStory !== STORY_TREANT) return;
            document.getElementById('storyText').innerHTML = "The tree gets angry and you are thrown into a battle against the Treant!";
            document.getElementById('storyChoices').style.display = 'none';

            document.getElementById('continueToBattleButton').style.display = 'inline-block';
            document.getElementById('continueToBattleButton').onclick = function() {
                hideStoryEventScreen();
                treantEncountered = true;
                startTreantBattle();
            };
        }

        function handleTreeAsk() {
            console.log("Executing handleTreeAsk");
            if (currentStory !== STORY_TREANT) return;
            document.getElementById('storyText').innerHTML = "The tree explains that its autumn has ended and it must sleep for the winter. It thanks you for listening and hands you a fruit that heals you completely, grants +5 HP, +1 max damage, and 15 XP.";

            if (player.expBooster) {
                player.experience += 30; // Double XP if booster is active
                player.expBooster = false; // Reset the XP booster after use
            } else {
                player.experience += 15;
            }

            player.health = player.maxHealth;
            player.maxHealth += 5;
            player.maxDamage += 1;

            checkStoryLevelUp();
            updateStoryScreenStats(); // Update stats on story screen

            showFinalContinueButton(); // Show final continue button and update stats

            // Show level-up message if player leveled up
            if (player.experience >= player.xpToNextLevel) {
                showLevelUpMessage();
            }
        }

        function handleTreeAsk2() {
            console.log("Executing handleTreeAsk2");
            if (currentStory !== STORY_TREANT) return;
            document.getElementById('storyText').innerHTML = "The tree explains that its autumn has ended and it must sleep for the winter. It thanks you for listening and hands you a fruit that heals you completely, grants +5 HP, +1 max damage, and 15 XP.";
        
            if (player.expBooster) {
                player.experience += 30; // Double XP if booster is active
                player.expBooster = false; // Reset the XP booster after use
            } else {
                player.experience += 15;
            }
        
            player.health = player.maxHealth;
            player.maxHealth += 5;
            player.maxDamage += 1;
        
            checkStoryLevelUp();
            updateStoryScreenStats(); // Update stats on story screen
        
            showFinalContinueButton(); // Show final continue button and update stats
        
            // Show level-up message if player leveled up
            if (player.experience >= player.xpToNextLevel) {
                showLevelUpMessage();
            }
        }

        function handleTreeLeave() {
            console.log("Executing handleTreeLeave");
            if (currentStory !== STORY_TREANT) return;
            document.getElementById('storyText').innerHTML = "You walk away, finding the whole situation very strange.";
            showFinalContinueButton(); // Show final continue button and update stats
        }
		
		function showStoryEvent3() {
			console.log("Entering showStoryEvent3");
			inStoryEvent = true;
			ensureButtonVisibility();
			currentStory = STORY_ABANDONED_HOUSE;
			document.getElementById('storyLevelUpMessage').style.display = 'none';
			document.getElementById('storyLevelUpMessage').innerHTML = '';
			document.getElementById('gameCanvas').style.display = 'none';
			document.getElementById('gameButtons').style.display = 'none';
			document.getElementById('storyEventScreen').style.display = 'block';
			document.getElementById('storyText').innerHTML = "You encounter an abandoned house right off the main road. You feel that something is calling to you from inside. It seems dangerous.";

			resetStoryChoices();  // Reset all choice buttons

			document.getElementById('storyChoice1Button').textContent = "Shout to see if you get a reply";
			document.getElementById('storyChoice2Button').textContent = "Walk up to the door";
			document.getElementById('storyChoice3Button').textContent = "Leave right away";

			removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

			document.getElementById('storyChoice1Button').addEventListener('click', handleAbandonedHouseShout);
			document.getElementById('storyChoice2Button').addEventListener('click', handleAbandonedHouseDoor);
			document.getElementById('storyChoice3Button').addEventListener('click', handleAbandonedHouseLeave);

			document.getElementById('storyChoices').style.display = 'block';
			document.getElementById('continueJourneyFromStoryButton').style.display = 'none';
			document.getElementById('continueToBattleButton').style.display = 'none';
			document.getElementById('storyStats').style.display = 'none';
		}
		
		function handleAbandonedHouseShout() {
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    document.getElementById('storyText').innerHTML = "You shout and a voice yells back 'Why are you being rude, stop yelling and come inside'";

    document.getElementById('storyChoice1Button').textContent = "Yell 'Who are you'";
    document.getElementById('storyChoice2Button').textContent = "Walk up to the door";
    document.getElementById('storyChoice3Button').textContent = "Walk away";

    removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

    document.getElementById('storyChoice1Button').addEventListener('click', handleAbandonedHouseYellWho);
    document.getElementById('storyChoice2Button').addEventListener('click', handleAbandonedHouseDoor);
    document.getElementById('storyChoice3Button').addEventListener('click', handleAbandonedHouseWalkAway);
}

function handleAbandonedHouseLeave() {
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    const goldFound = Math.floor(Math.random() * (100 - 25 + 1)) + 25;
    player.gold += goldFound;
    document.getElementById('storyText').innerHTML = `You leave and find a coin purse on the road. You receive ${goldFound} gold.`;
    showFinalContinueButton();
}

function handleAbandonedHouseYellWho() {
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    document.getElementById('storyText').innerHTML = "No one replies.";

    document.getElementById('storyChoice1Button').textContent = "Walk up to the door";
    document.getElementById('storyChoice2Button').textContent = "Walk away";
    document.getElementById('storyChoice3Button').style.display = 'none';

    removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

    document.getElementById('storyChoice1Button').addEventListener('click', handleAbandonedHouseDoor);
    document.getElementById('storyChoice2Button').addEventListener('click', handleAbandonedHouseWalkAway);
}

function handleAbandonedHouseWalkAway() {
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    document.getElementById('storyText').innerHTML = "As you walk away, an angry spirit attacks you!";
    document.getElementById('storyChoices').style.display = 'none';
    document.getElementById('continueToBattleButton').style.display = 'inline-block';
    document.getElementById('continueToBattleButton').onclick = function() {
        hideStoryEventScreen();
        startAngrySpirit();
    };
}

function handleAbandonedHouseDoor() {
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    document.getElementById('storyText').innerHTML = "You walk up to the door.";

    document.getElementById('storyChoice1Button').textContent = "Open door";
    document.getElementById('storyChoice2Button').textContent = "Knock on the door";
    document.getElementById('storyChoice3Button').style.display = 'none';

    removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

    document.getElementById('storyChoice1Button').addEventListener('click', handleAbandonedHouseOpenDoor);
    document.getElementById('storyChoice2Button').addEventListener('click', handleAbandonedHouseKnock);

    console.log("Door options set up"); // Add this log for debugging
}

function handleAbandonedHouseOpenDoor() {
    console.log("Opening the door"); // Add this log for debugging
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    document.getElementById('storyText').innerHTML = "You open the door. An angry spirit screams that you have no manners and attacks you!";
    document.getElementById('storyChoices').style.display = 'none';
    document.getElementById('continueToBattleButton').style.display = 'inline-block';
    document.getElementById('continueToBattleButton').onclick = function() {
        hideStoryEventScreen();
        startAngrySpirit();
    };
}

function handleAbandonedHouseKnock() {
    console.log("Knocking on the door"); // Add this log for debugging
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    document.getElementById('storyText').innerHTML = "A spirit invites you in.";

    document.getElementById('storyChoice1Button').textContent = "Accept the invitation";
    document.getElementById('storyChoice2Button').textContent = "Refuse and leave";
    document.getElementById('storyChoice3Button').style.display = 'none';

    removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

    document.getElementById('storyChoice1Button').addEventListener('click', handleAbandonedHouseAccept);
    document.getElementById('storyChoice2Button').addEventListener('click', handleAbandonedHouseWalkAway);
}

function handleAbandonedHouseAccept() {
    if (currentStory !== STORY_ABANDONED_HOUSE) return;
    document.getElementById('storyText').innerHTML = "You are invited in. There is a feast setup on the dining table. The food and drink are amazing and delicious. You have a great time, and the spirit grants you an HP potion and a coin purse with 500 Gold. You gain 25 XP. The HP potion grants 5 maximum HP, and your HP is restored.";
    
    player.gold += 500;
    player.experience += 25;
    player.maxHealth += 5;
    player.health = player.maxHealth;
    
    checkStoryLevelUp();
    updateStoryScreenStats();
    showFinalContinueButton();
}

function startAngrySpirit() {
    console.log("Starting Angry Spirit battle");
    const angrySpirit = createEnemyByType('Angry Spirit');
    if (!angrySpirit) {
        console.error("Failed to create Angry Spirit enemy");
        return;
    }
    
    enemies = [angrySpirit];
    gameState = 'playerTurn';
    hideAllScreens();
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('gameButtons').style.display = 'block';
    updateButtonStates();
    drawGame();
    inStoryEvent = false;
}
    
	function showStoryEvent4() {
    console.log("Entering showStoryEvent4");
    inStoryEvent = true;
    ensureButtonVisibility();
    currentStory = STORY_CHILLING_SCREAM;
    document.getElementById('storyLevelUpMessage').style.display = 'none';
    document.getElementById('storyLevelUpMessage').innerHTML = '';
    document.getElementById('gameCanvas').style.display = 'none';
    document.getElementById('gameButtons').style.display = 'none';
    document.getElementById('storyEventScreen').style.display = 'block';
    document.getElementById('storyText').innerHTML = "You are walking on the main road at night. It's a cloudless sky tonight filled with countless stars, truly a beautiful sight. You start to think that this is such a pretty night and so peaceful when suddenly you hear a chilling scream in the woods to your right. It stops you in your tracks, your gaze fixed towards the position you heard the scream coming from. What should you do?";

	resetStoryChoices();  // Reset all choice buttons
	
    document.getElementById('storyChoice1Button').textContent = "Run towards the scream";
    document.getElementById('storyChoice2Button').textContent = "Walk with caution towards the scream";
    document.getElementById('storyChoice3Button').textContent = "Not my problem and walk away";

    removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

    document.getElementById('storyChoice1Button').addEventListener('click', handleChillingScreamRun);
    document.getElementById('storyChoice2Button').addEventListener('click', handleChillingScreamCaution);
    document.getElementById('storyChoice3Button').addEventListener('click', handleChillingScreamIgnore);

    document.getElementById('storyChoices').style.display = 'block';
    document.getElementById('continueJourneyFromStoryButton').style.display = 'none';
    document.getElementById('continueToBattleButton').style.display = 'none';
    document.getElementById('storyStats').style.display = 'none';
}

	function handleChillingScreamRun() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You start running as fast as you can through the woods in the direction you heard the scream. A couple of moments later you find the source of the scream. You see a werewolf slowly approaching a woman that's on the floor, she is petrified with fear, trembling, staring at the beast as it slowly advances towards her.";

    document.getElementById('storyChoice1Button').textContent = "Run towards the werewolf and attack it";
    document.getElementById('storyChoice2Button').textContent = "Stay hidden and watch what happens";
    document.getElementById('storyChoice3Button').textContent = "Give into your fear and run away";

    removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

    document.getElementById('storyChoice1Button').addEventListener('click', handleChillingScreamAttack);
    document.getElementById('storyChoice2Button').addEventListener('click', handleChillingScreamHide);
    document.getElementById('storyChoice3Button').addEventListener('click', handleChillingScreamFlee);
}

function handleChillingScreamAttack() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You bravely run towards the werewolf to attack it!";
    document.getElementById('storyChoices').style.display = 'none';
    document.getElementById('continueToBattleButton').style.display = 'inline-block';
    document.getElementById('continueToBattleButton').onclick = function() {
        hideStoryEventScreen();
        startWerewolfBattle();
    };
}

function handleChillingScreamHide() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You hide and watch as a second later the werewolf leaps on the woman and starts attacking and ripping her flesh. You watch in horror as it starts eating his victim and with a howl, the werewolf runs off deeper into the woods. You go to the dead woman's body and find a pouch with 400 Gold and an HP cookie.";
    
    player.gold += 400;
    player.maxHealth += 2;
    player.experience += 20;
    
    checkStoryLevelUp();
    updateStoryScreenStats();
    showFinalContinueButton();
}

function handleChillingScreamFlee() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You give into your fear and run away as fast as you can.";
    showFinalContinueButton();
}

function handleChillingScreamIgnore() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You keep walking but at a faster pace. You hear a second scream and you start running out of there.";
    showFinalContinueButton();
}

function handleChillingScreamCaution() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You start walking towards the scream, alert to every sound and movement. Suddenly, you hear a second visceral scream that sends shivers down your spine.";

    document.getElementById('storyChoice1Button').textContent = "Run towards the visceral scream";
    document.getElementById('storyChoice2Button').textContent = "Continue your cautious approach";
    document.getElementById('storyChoice3Button').textContent = "Turn around and leave";

    removeEventListeners('storyChoice1Button', 'storyChoice2Button', 'storyChoice3Button');

    document.getElementById('storyChoice1Button').addEventListener('click', handleChillingScreamVisceral);
    document.getElementById('storyChoice2Button').addEventListener('click', handleChillingScreamContinueCaution);
    document.getElementById('storyChoice3Button').addEventListener('click', handleChillingScreamTurnAround);
}

function handleChillingScreamVisceral() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You run at full speed towards the scream. Within seconds you reach the source. You see a werewolf attacking a woman on the ground. It's feasting upon her body when it snaps its head towards you. The werewolf immediately lounges at you!";
    document.getElementById('storyChoices').style.display = 'none';
    document.getElementById('continueToBattleButton').style.display = 'inline-block';
    document.getElementById('continueToBattleButton').onclick = function() {
        hideStoryEventScreen();
        startWerewolfBattle();
    };
}

function handleChillingScreamContinueCaution() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You continue to creep forward, not wanting to alert anything of your presence. You eventually find the source of the screams. There is a dead body that has been eaten and mangled beyond recognition. You find a pouch with 300 gold and an HP cookie.";
    
    player.gold += 300;
    player.maxHealth += 2;
    player.experience += 15;
    
    checkStoryLevelUp();
    updateStoryScreenStats();
    showFinalContinueButton();
}

function handleChillingScreamTurnAround() {
    if (currentStory !== STORY_CHILLING_SCREAM) return;
    document.getElementById('storyText').innerHTML = "You decide it is not worth continuing forward and turn around to leave. Just before reaching the road, you find a berry bush and decide to eat some.";
    
    player.health = Math.min(player.health + 5, player.maxHealth);
    
    updateStoryScreenStats();
    showFinalContinueButton();
}

function startWerewolfBattle() {
    console.log("Starting Werewolf battle");
    const werewolf = createEnemyByType('Werewolf');
    if (!werewolf) {
        console.error("Failed to create Werewolf enemy");
        return;
    }
    
    enemies = [werewolf];
    gameState = 'playerTurn';
    hideAllScreens();
    document.getElementById('gameContainer').style.display = 'block';
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('gameButtons').style.display = 'block';
    updateButtonStates();
    drawGame();
    inStoryEvent = false;
    
    // Set the current story context
    currentStoryContext = STORY_CHILLING_SCREAM;
    console.log("Set currentStoryContext to:", currentStoryContext);
}
   

        function showFinalContinueButton() {
			console.log("Executing showFinalContinueButton");
			updateStoryScreenStats();
			document.getElementById('storyChoices').style.display = 'none';
			document.getElementById('storyStats').style.display = 'block';
			document.getElementById('continueToBattleButton').style.display = 'none';

			inStoryEvent = false;
			gameState = 'storyComplete';

			let buttonContainer = document.getElementById('storyFinalButtons');
			if (!buttonContainer) {
				buttonContainer = document.createElement('div');
				buttonContainer.id = 'storyFinalButtons';
				document.getElementById('storyEventScreen').appendChild(buttonContainer);
			}
			buttonContainer.style.display = 'block';

			let continueButton = document.getElementById('continueJourneyFromStoryButton');
			if (!continueButton) {
				continueButton = document.createElement('button');
				continueButton.id = 'continueJourneyFromStoryButton';
				continueButton.textContent = 'Continue Journey';
				buttonContainer.appendChild(continueButton);
			}
			continueButton.onclick = continueJourneyFromStory;
			continueButton.style.display = 'inline-block';

			let campButton = document.getElementById('returnToCampFromStoryButton');
			if (!campButton) {
				campButton = document.createElement('button');
				campButton.id = 'returnToCampFromStoryButton';
				campButton.textContent = 'Return to Camp';
				buttonContainer.appendChild(campButton);
			}
			campButton.onclick = returnToCampFromStory;
			campButton.style.display = 'inline-block';

			console.log("Continue journey and Return to Camp buttons should now be visible");

			resetStoryChoices();  // Reset all choice buttons
			ensureButtonVisibility();
			autoSave();
			updateLoadGameButton();
		}

        function startTreantBattle() {
    console.log("Executing startTreantBattle");
    treantEncountered = true;
    
    const treantEnemy = createEnemyByType('Treant');
    if (!treantEnemy) {
        console.error("Failed to create Treant enemy");
        return;
    }
    
    enemies = [treantEnemy];
    console.log("Enemies array:", enemies);
    
    gameState = 'playerTurn';
    console.log("Game state set to:", gameState);
    
    // Hide all screens first
    hideAllScreens();
    console.log("All screens hidden");
    
    // Show the game container and canvas
    const gameContainer = document.getElementById('gameContainer');
    if (gameContainer) {
        gameContainer.style.display = 'block';
        console.log("Game container display set to block");
    } else {
        console.error("Game container element not found");
    }
    
    const canvas = document.getElementById('gameCanvas');
    if (canvas) {
        canvas.style.display = 'block';
        console.log("Canvas display set to block");
    } else {
        console.error("Canvas element not found");
    }
    
    const gameButtons = document.getElementById('gameButtons');
    if (gameButtons) {
        gameButtons.style.display = 'block';
        console.log("Game buttons display set to block");
    } else {
        console.error("Game buttons element not found");
    }
    
    updateButtonStates();
    console.log("Button states updated");
    
    console.log("Attempting to draw game");
    drawGame();
    console.log("Game drawn");
    
    // Set inStoryEvent to false as we're now in battle
    inStoryEvent = false;
    console.log("inStoryEvent set to false");

    // Force a redraw after a short delay
    setTimeout(() => {
        console.log("Forcing redraw");
        drawGame();
    }, 100);
}

        function continueJourneyFromCamp() {
			console.log("Executing continueJourneyFromCamp");
			hideCampScreen();
			document.getElementById('continueJourneyFromCampButton').style.display = 'none';
			resetPurchasedItems(); // Reset purchased items when leaving camp
			gameState = 'exploring'; // Set a transitional state
			continueJourney();
		}
        
        function continueJourneyFromStory() {
			console.log("Executing continueJourneyFromStory");
			hideStoryEventScreen();
			inStoryEvent = false;
			gameState = 'exploring'; // Set game state to exploring
			ensureButtonVisibility(); // Update button visibility
			continueJourney();
		}

		function returnToCampFromStory() {
			console.log("Executing returnToCampFromStory");
			hideStoryEventScreen();
			inStoryEvent = false;
			gameState = 'camp'; // Set game state to camp
			ensureButtonVisibility(); // Update button visibility
			showCampScreen();
		}

		function resetPurchasedItems() {
			player.purchasedItems = {
				healingPotion: 0,
				expBooster: false,
				antidote: false,
				lotus: false,
				redPill: false
			};
		}
		
		function hideDuelEventScreen() {
			document.getElementById('duelEventScreen').style.display = 'none';
		}

        function hideStoryEventScreen() {
			document.getElementById('storyEventScreen').style.display = 'none';
			const buttonContainer = document.getElementById('storyFinalButtons');
			if (buttonContainer) {
				buttonContainer.style.display = 'none';
			}
		}

        function updateStoryScreenStats() {
            console.log("Executing updateStoryScreenStats");
            const statsMessage = `Health: ${player.health}/${player.maxHealth}<br>
            Min Damage: ${player.minDamage}<br>
            Max Damage: ${player.maxDamage}<br>
            XP: ${player.experience}/${player.xpToNextLevel}<br>
            Current Gold: ${player.gold}<br><br>
            Camp Bank: ${player.campBank} Gold`;

            document.getElementById('storyStats').innerHTML = statsMessage;
        }

        // Utility function to remove event listeners
        function removeEventListeners(...buttonIds) {
            buttonIds.forEach(buttonId => {
                const button = document.getElementById(buttonId);
                const oldElement = button.cloneNode(true);
                button.parentNode.replaceChild(oldElement, button);
            });
        }

        function showStorySkillSelection() {
			console.log("Showing story skill selection for " + player.class);
			const skillSelection = document.getElementById('storySkillSelection');
			
			skillSelection.style.display = 'block';
			document.getElementById('continueJourneyFromStoryButton').style.display = 'none';
			document.getElementById('storyChoices').style.display = 'none';

			const mageSkills = document.getElementById('storySkillSelectionMageSkills');
			const warriorSkills = document.getElementById('storySkillSelectionWarriorSkills');
			const clericSkills = document.getElementById('storySkillSelectionClericSkills');
			const rogueSkills = document.getElementById('storySkillSelectionRogueSkills');

			mageSkills.style.display = 'none';
			warriorSkills.style.display = 'none';
			clericSkills.style.display = 'none';
			rogueSkills.style.display = 'none';

			let skillsToShow;
			if (player.class === 'Mage') {
				skillsToShow = mageSkills;
			} else if (player.class === 'Warrior') {
				skillsToShow = warriorSkills;
			} else if (player.class === 'Cleric') {
				skillsToShow = clericSkills;
			} else if (player.class === 'Rogue') {
				skillsToShow = rogueSkills;
			}

			if (skillsToShow) {
				skillsToShow.style.display = 'block';
				// Set up skill buttons
				const buttons = skillsToShow.getElementsByTagName('button');
				for (let i = 0; i < buttons.length; i++) {
					const skillName = buttons[i].textContent;
					buttons[i].onclick = () => selectSpecialSkill(skillName);
				}
			}
			
			ensureButtonVisibility();
		}

        function showBattleSkillSelection() {
    console.log("Showing battle skill selection for " + player.class);
    const skillSelection = document.getElementById('skillSelection');
    
    skillSelection.style.display = 'block';
    document.getElementById('continueJourneyButton').style.display = 'none';
    document.getElementById('returnToCampButton').style.display = 'none';
    
    const classSkillsDiv = document.getElementById(`skillSelection${player.class}Skills`);
    if (classSkillsDiv) {
        console.log(`Displaying ${player.class} skills`);
        classSkillsDiv.style.display = 'block';
        
        // Clear existing buttons and add new ones
        classSkillsDiv.innerHTML = '';
        Object.keys(player.specialSkills).forEach(skillName => {
            const button = document.createElement('button');
            button.textContent = skillName;
            button.onclick = () => selectSpecialSkill(skillName);
            classSkillsDiv.appendChild(button);
        });
    } else {
        console.error(`Skill selection div not found for ${player.class}`);
    }
    
    ensureButtonVisibility();
}

        function showLevelUpMessage() {
            let levelUpMessage = `You leveled up! Gained ${player.healthGain} health, +${player.minDamageGain} min damage, +${player.maxDamageGain} max damage.`;
            document.getElementById('storyLevelUpMessage').innerHTML = levelUpMessage;
            document.getElementById('storyLevelUpMessage').style.display = 'block';
            
            // Clear the message after 5 seconds
            setTimeout(() => {
                document.getElementById('storyLevelUpMessage').style.display = 'none';
                document.getElementById('storyLevelUpMessage').innerHTML = '';
            }, 5000);
        }
        
        function setupClassSkills() {
    console.log("Setting up class skills for:", player.class);
    player.specialSkills = getClassSkills(player.class);
    console.log("Special skills set:", player.specialSkills);
    
    // Don't assign a special skill here, it will be done when the player selects one
    updateSpecialAttackButton();
}

function getClassSkills(characterClass) {
    switch (characterClass) {
        case 'Warrior':
            return {
                'Double Attack': {
                    name: 'Double Attack',
                    use: function(user, target) {
                        let totalDamage = 0;
                        for (let i = 0; i < 2; i++) {
                            const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage;
                            totalDamage += damage;
                        }
                        return {
                            damage: totalDamage,
                            effect: `${user.class} used Double Attack for ${totalDamage} damage!`
                        };
                    }
                },
                'Stone Skin': {
                    name: 'Stone Skin',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage;
                        return {
                            damage: damage,
                            effect: `${user.class} used Stone Skin, dealt ${damage} damage, and is now defending!`,
                            applyEffect: () => { user.defending = true; }
                        };
                    }
                },
                'Life Attack': {
                    name: 'Life Attack',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage;
                        const healAmount = Math.floor(damage / 2);
                        return {
                            damage: damage,
                            effect: `${user.class} used Life Attack for ${damage} damage and healed for ${healAmount}!`,
                            applyEffect: () => {
                                user.health = Math.min(user.health + healAmount, user.maxHealth);
                            }
                        };
                    }
                }
            };
        case 'Mage':
            return {
                'Thunder': {
                    name: 'Thunder',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage + 1;
                        return {
                            damage: damage,
                            effect: `${user.class} used Thunder for ${damage} damage and stunned the target!`,
                            applyEffect: (target) => { target.stunnedTurns = 1; }
                        };
                    }
                },
                'Fireball': {
                    name: 'Fireball',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage + 2;
                        return {
                            damage: damage,
                            effect: `${user.class} used Fireball for ${damage} damage and burned the target!`,
                            applyEffect: (target) => { target.burnedTurns = 2; }
                        };
                    }
                },
                'Hail Storm': {
                    name: 'Hail Storm',
                    use: function(user, targets) {
                        const damage = Math.floor(Math.random() * (user.maxDamage / 2 - user.minDamage / 2 + 1)) + user.minDamage / 2 + 1;
                        return {
                            damage: damage,
                            effect: `${user.class} used Hail Storm for ${damage} damage to all enemies!`,
                            isAOE: true
                        };
                    }
                }
            };
        case 'Cleric':
            return {
                'Holy Light': {
                    name: 'Holy Light',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage + 1;
                        return {
                            damage: damage,
                            effect: `${user.class} used Holy Light for ${damage} damage and exposed the target!`,
                            applyEffect: (target) => { target.exposed = true; }
                        };
                    }
                },
                'Life Transfer': {
                    name: 'Life Transfer',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage + 1;
                        return {
                            damage: damage,
                            effect: `${user.class} used Life Transfer, dealing ${damage} damage to the enemy and healing for ${damage} HP!`,
                            applyEffect: () => {
                                user.health = Math.min(user.health + damage, user.maxHealth);
                            }
                        };
                    }
                },
                'Shield of Light': {
                    name: 'Shield of Light',
                    use: function(user) {
                        return {
                            damage: 0,
                            effect: `${user.class} used Shield of Light and is now protected for 2 turns with increased damage!`,
                            applyEffect: () => {
                                user.shieldOfLight = 2;
                                user.maxDamage += 2;
                            }
                        };
                    }
                }
            };
        case 'Rogue':
            return {
                'Blind Shot': {
                    name: 'Blind Shot',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage + 1;
                        return {
                            damage: damage,
                            effect: `${user.class} used Blind Shot for ${damage} damage and blinded the target (100% chance to miss)!`,
                            applyEffect: (target) => { target.blind = 100; }
                        };
                    }
                },
                'Toxic Stab': {
                    name: 'Toxic Stab',
                    use: function(user, target) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage + 2;
                        return {
                            damage: damage,
                            effect: `${user.class} used Toxic Stab for ${damage} damage and poisoned the target!`,
                            applyEffect: (target) => { 
                                if (!target.poisonCounter) {
                                    target.poisonCounter = 1;
                                } else {
                                    target.poisonCounter++;
                                }
                            }
                        };
                    }
                },
                'Perfect Parry': {
                    name: 'Perfect Parry',
                    use: function(user) {
                        const damage = Math.floor(Math.random() * (user.maxDamage - user.minDamage + 1)) + user.minDamage + 1;
                        return {
                            damage: 0,
                            effect: `${user.class} used Perfect Parry, dealing ${damage} damage on the next enemy attack and is ready to counter!`,
                            applyEffect: () => { user.parry = true; }
                        };
                    }
                }
            };
        default:
            console.error(`Unknown class: ${characterClass}`);
            return {};
    }
}

function displayMessage(message) {
    console.log("Game Message:", message);
    // You can implement this function to display the message in your game UI
    // For example:
    // const messageElement = document.getElementById('gameMessages');
    // messageElement.textContent = message;
    // messageElement.style.display = 'block';
}

        function selectSpecialSkill(skillName) {
    console.log("Selecting special skill: " + skillName);
    
    // Don't modify the skillName, use it as is
    if (player.specialSkills[skillName]) {
        player.specialSkill = player.specialSkills[skillName];
        console.log("Selected skill:", player.specialSkill);
        
        // Hide all skill selection screens
        document.getElementById('skillSelection').style.display = 'none';
        document.getElementById('storySkillSelection').style.display = 'none';
        
        // Update the special attack button
        updateSpecialAttackButton();
        
        if (inStoryEvent) {
            showFinalContinueButton();
        } else {
            document.getElementById('continueJourneyButton').style.display = 'inline-block';
            document.getElementById('returnToCampButton').style.display = 'inline-block';
        }
        
        console.log("Journey and Camp buttons should now be visible");
        
        // Save the game after selecting a skill
        saveGame();
        
        // If we're in a battle, redraw the game
        if (gameState === 'playerTurn' || gameState === 'enemyTurn') {
            drawGame();
        }
        
        ensureButtonVisibility();
    } else {
        console.error("Skill not found:", skillName);
        console.log("Available skills:", Object.keys(player.specialSkills));
    }
}

        function updateSpecialAttackButton() {
    console.log("Updating special attack button");
    console.log("Player special skill:", player.specialSkill);
    console.log("Special skill unlocked:", player.specialSkillUnlocked);
    console.log("Special attack cooldown:", player.specialAttackCooldown);

    const specialAttackButton = document.getElementById('specialAttackButton');
    if (player.specialSkill && player.specialSkillUnlocked) {
        specialAttackButton.style.display = 'inline-block';
        if (player.specialAttackCooldown > 0) {
            specialAttackButton.textContent = `${player.specialSkill.name} (${player.specialAttackCooldown})`;
            specialAttackButton.classList.remove('available');
            specialAttackButton.classList.add('cooldown');
            specialAttackButton.disabled = true;
        } else {
            specialAttackButton.textContent = player.specialSkill.name;
            specialAttackButton.classList.add('available');
            specialAttackButton.classList.remove('cooldown');
            specialAttackButton.disabled = false;
        }
    } else {
        specialAttackButton.style.display = 'none';
    }
}

        function ensureButtonVisibility() {
            const continueButton = document.getElementById('continueJourneyButton');
            const campButton = document.getElementById('returnToCampButton');
            const storyButton = document.getElementById('continueJourneyFromStoryButton');
            const storyChoices = document.getElementById('storyChoices');
            const skillSelection = document.getElementById('skillSelection');
            const storySkillSelection = document.getElementById('storySkillSelection');
        
            // Check if skill selection is active
            const isSkillSelectionActive = (skillSelection && skillSelection.style.display !== 'none') || 
                                           (storySkillSelection && storySkillSelection.style.display !== 'none');
        
            console.log("Current state:", { inStoryEvent, gameState, isSkillSelectionActive });
        
            if (isSkillSelectionActive) {
                // If skill selection is active, hide all journey buttons
                storyButton.style.display = 'none';
                continueButton.style.display = 'none';
                campButton.style.display = 'none';
            } else if (inStoryEvent) {
                // In a story event
                if (storyChoices.style.display !== 'none') {
                    // Choices are still visible, buttons should be hidden
                    storyButton.style.display = 'none';
                    continueButton.style.display = 'none';
                    campButton.style.display = 'none';
                } else {
                    // Choices are hidden, story continue button should be visible
                    storyButton.style.display = 'inline-block';
                    continueButton.style.display = 'none';
                    campButton.style.display = 'none';
                }
            } else if (gameState === 'storyComplete') {
                // Story is complete, show the continue journey button
                storyButton.style.display = 'inline-block';
                continueButton.style.display = 'none';
                campButton.style.display = 'none';
            } else if (gameState === 'victory') {
                // Victory screen, show continue journey and return to camp buttons
                storyButton.style.display = 'none';
                continueButton.style.display = 'inline-block';
                campButton.style.display = 'inline-block';
            } else {
                // Default case, hide all buttons
                storyButton.style.display = 'none';
                continueButton.style.display = 'none';
                campButton.style.display = 'none';
            }
        
            console.log("Button visibility updated:", {
                storyButton: storyButton.style.display,
                continueButton: continueButton.style.display,
                campButton: campButton.style.display
            });
        }

        setInterval(ensureButtonVisibility, 5000); // Check every 5 seconds

        window.onerror = function(message, source, lineno, colno, error) {
    console.error("An error occurred:", message, "at", source, ":", lineno);
    ensureButtonVisibility(); // Try to recover
    return false;
};

        function buyTent(tentNumber, cost) {
    if (player.campBank >= cost) {
        player.campBank -= cost;
        player.tents++;
        console.log(`Bought tent ${tentNumber}. New tent count:`, player.tents);
		updateCampMessage();
        
        // Hide all tent buttons first
        ['second', 'third', 'fourth', 'fifth'].forEach(tentWord => {
            const button = document.getElementById(`${tentWord}TentButton`);
            if (button) button.style.display = 'none';
        });
        
        // Show only the next buy button if applicable
        if (player.tents < 5) {
            const nextButtonWord = getTentNumberWord(player.tents + 1);
            const nextButton = document.getElementById(`${nextButtonWord}TentButton`);
            if (nextButton) nextButton.style.display = 'block';
        }
        
        if (!duelEventsUnlocked) {
            duelEventsUnlocked = true;
            console.log("Duel events unlocked!");
            alert("You've unlocked Duel Events!");
        }
        
        // Update the camp screen without affecting button visibility
        updatePlayerTents();
        updateCommercialTents();
        updateCampBankDisplay();
		updateTentButtonStates();
		logButtonStates();
    } else {
        alert("Not enough gold in the Camp Bank!");
    }
}

function updateCampBankDisplay() {
    const campBankDisplay = document.getElementById('campBankDisplay');
    if (campBankDisplay) {
        campBankDisplay.textContent = `Camp Bank: ${player.campBank} Gold`;
    } else {
        console.warn('Camp bank display element not found');
    }
}

        function getTentNumberWord(number) {
    const words = ['', 'second', 'third', 'fourth', 'fifth'];
    return words[number - 1] || '';
}

function buyMerchantTent() {
    const merchantTentCost = 1000;
    if (player.campBank >= merchantTentCost) {
        player.campBank -= merchantTentCost;
        player.merchantTent = true;
        
        // Hide merchant tent button
        const merchantTentButton = document.getElementById('merchantTentButton');
        if (merchantTentButton) {
            merchantTentButton.style.display = 'none';
        }
        
        // Update camp bank display
        updateCampBankDisplay();
        
        updateCampMessage();
        
        // Update commercial tents (to show the new merchant tent)
        updateCommercialTents();
        
        // Show the shop
        showShopInCamp();
        
        // Update tent button states without changing their visibility
        updateTentButtonStates();
        
        alert("You've purchased the Merchant Tent!");
    } else {
        alert("Not enough gold in the Camp Bank!");
    }
}

function updateTentButtonStates() {
    const tentCosts = [1500, 2000, 2500, 3000]; // Costs for 2nd, 3rd, 4th, and 5th tents
    const tentWords = ['second', 'third', 'fourth', 'fifth'];
    
    for (let i = 0; i < tentWords.length; i++) {
        const button = document.getElementById(`${tentWords[i]}TentButton`);
        if (button) {
            const isVisible = button.style.display !== 'none';
            const canAfford = player.campBank >= tentCosts[i];
            button.disabled = !canAfford;
            if (isVisible) {
                button.textContent = `Buy ${tentWords[i].charAt(0).toUpperCase() + tentWords[i].slice(1)} Tent (${tentCosts[i]} Gold)`;
                button.style.opacity = canAfford ? '1' : '0.5';
            }
        }
    }
    
    // Update merchant tent button
    const merchantButton = document.getElementById('merchantTentButton');
    if (merchantButton && !player.merchantTent) {
        const canAffordMerchant = player.campBank >= 1000;
        merchantButton.disabled = !canAffordMerchant;
        merchantButton.textContent = `Buy Merchant Tent (1000 Gold)`;
        merchantButton.style.opacity = canAffordMerchant ? '1' : '0.5';
    }
}

        function updateCampMessage() {
    const campMessageElement = document.getElementById('campMessage');
    if (campMessageElement) {
        campMessageElement.innerHTML = `
            HP: ${player.health}/${player.maxHealth}<br>
            Min Damage: ${player.minDamage}<br>
            Max Damage: ${player.maxDamage}<br>
            XP: ${player.experience}/${player.xpToNextLevel}<br>
            Current Gold: ${player.gold}<br>
            Camp Bank: ${player.campBank} Gold
        `;
    }
}

        function startDuelEvent() {
			console.log("Starting duel event");
			const classes = ['Warrior', 'Mage', 'Cleric', 'Rogue'];
			const enemyClass = classes[Math.floor(Math.random() * classes.length)];
			const enemy = createEnemyCharacter(enemyClass);
			
			hideAllScreens();
			document.getElementById('duelEventScreen').style.display = 'block';
			document.getElementById('duelText').innerHTML = `You've encountered a ${enemyClass} who challenges you to a duel!`;
			document.getElementById('startDuelButton').onclick = () => startDuelBattle(enemy);
			
			// Reset game state
			gameState = 'duel';
			inStoryEvent = false;
		}

        function createEnemyCharacter(characterClass) {
            const enemy = {
                type: characterClass,  // Add this line
                class: characterClass,
                health: 50,
                maxHealth: 50,
                minDamage: 1,
                maxDamage: 6,
                specialSkill: getRandomSkill(characterClass),
                specialAttackCooldown: 0  // Add this line
            };
            return enemy;
        }

        function getRandomSkill(characterClass) {
            // Return a random skill based on the character class
            const skills = {
                Warrior: ['DoubleAttack', 'StoneSkin', 'LifeAttack'],
                Mage: ['Thunder', 'Fireball', 'HailStorm'],
                Cleric: ['HolyLight', 'LifeTransfer', 'ShieldOfLight'],
                Rogue: ['BlindShot', 'ToxicStab', 'PerfectParry']
            };
            return skills[characterClass][Math.floor(Math.random() * skills[characterClass].length)];
        }

        function startDuelBattle(enemy) {
			console.log("Starting duel battle");
			currentBattleExpGained = 0;
			enemies = [enemy];
			gameState = 'playerTurn';
			
			hideAllScreens();
			document.getElementById('gameContainer').style.display = 'flex';
			document.getElementById('gameCanvas').style.display = 'block';
			document.getElementById('gameButtons').style.display = 'flex';
			
			updateSpecialAttackButton();
			updateButtonStates();
			drawGame();
			showPlayerTurnNotification();
		}

        function showDuelVictoryScreen(defeatedEnemy) {
    console.log("Showing duel victory screen");
    const victoryScreen = document.getElementById('duelVictoryScreen');
    victoryScreen.style.display = 'block';
    
    // Hide other elements
    document.getElementById('gameContainer').style.display = 'none';
    document.getElementById('gameButtons').style.display = 'none';
    
    // Set victory message
    document.getElementById('duelVictoryMessage').textContent = `You've defeated the ${defeatedEnemy.class}!`;
    
    // Show recruit button only if there's an empty tent available
    const recruitButton = document.getElementById('recruitButton');
    if (player.recruitedCharacters.length < (player.tents - 1)) {
        recruitButton.style.display = 'inline-block';
        recruitButton.disabled = false;
        recruitButton.onclick = function() { recruitCharacter(defeatedEnemy); };
    } else {
        recruitButton.style.display = 'none';
    }
    
    // Create a container for the buttons if it doesn't exist
    let buttonContainer = document.getElementById('duelVictoryButtons');
    if (!buttonContainer) {
        buttonContainer = document.createElement('div');
        buttonContainer.id = 'duelVictoryButtons';
        victoryScreen.appendChild(buttonContainer);
    }
    buttonContainer.style.display = 'block';

    // Ensure the continue journey button is present and clickable
    let continueButton = document.getElementById('continueDuelJourneyButton');
    if (!continueButton) {
        continueButton = document.createElement('button');
        continueButton.id = 'continueDuelJourneyButton';
        continueButton.textContent = 'Continue Journey';
        buttonContainer.appendChild(continueButton);
    }
    continueButton.onclick = continueDuelJourney;
    continueButton.style.display = 'inline-block';

    // Add or show the Return to Camp button
    let campButton = document.getElementById('returnToCampFromDuelButton');
    if (!campButton) {
        campButton = document.createElement('button');
        campButton.id = 'returnToCampFromDuelButton';
        campButton.textContent = 'Return to Camp';
        buttonContainer.appendChild(campButton);
    }
    campButton.onclick = returnToCampFromDuel;
    campButton.style.display = 'inline-block';

    console.log("Continue journey and Return to Camp buttons should now be visible");
    
    autoSave();
    updateLoadGameButton();
}

function recruitCharacter(defeatedEnemy) {
    console.log("Recruit character function called");
    if (!player.recruitedCharacters) {
        player.recruitedCharacters = [];
    }
    
    if (player.recruitedCharacters.length < (player.tents - 1)) {
        player.recruitedCharacters.push({class: defeatedEnemy.class});
        alert(`You've recruited the ${defeatedEnemy.class}!`);
        document.getElementById('recruitButton').style.display = 'none';
        updatePlayerTents(); // Update the player tents
        console.log("Recruited character:", defeatedEnemy.class);
        console.log("Current recruited characters:", player.recruitedCharacters);
    } else {
        alert("You don't have enough empty tents to recruit this character!");
    }
}

function returnToCampFromDuel() {
    console.log("Executing returnToCampFromDuel");
    hideDuelVictoryScreen();
    gameState = 'camp';
    showCampScreen();
    updatePartyDisplay(); // Add this line
}

function hideDuelVictoryScreen() {
    console.log("Hiding duel victory screen");
    const victoryScreen = document.getElementById('duelVictoryScreen');
    if (victoryScreen) {
        victoryScreen.style.display = 'none';
    } else {
        console.warn("Duel victory screen element not found");
    }
    const buttonContainer = document.getElementById('duelVictoryButtons');
    if (buttonContainer) {
        buttonContainer.style.display = 'none';
    } else {
        console.warn("Duel victory buttons container not found");
    }
}

function updateCampScreen() {
    console.log("Updating camp screen");
    console.log("Player class:", player.class);
    console.log("Recruited characters:", player.recruitedCharacters);
    console.log("Total tents:", player.tents);
    console.log("Current party:", player.party);

    const playerTentsRow = document.getElementById('playerTentsRow');
    if (!playerTentsRow) {
        console.error("playerTentsRow not found");
        return;
    }

    // Clear existing tents
    playerTentsRow.innerHTML = '';

    // Ensure recruitedCharacters and party are initialized
    if (!player.recruitedCharacters) player.recruitedCharacters = [];
    if (!player.party) player.party = [];

    // Create and update all tents
    for (let i = 1; i <= player.tents; i++) {
        const tentElement = createTentElement(i);
        playerTentsRow.appendChild(tentElement);

        if (i === 1) {
            updateTentContent(tentElement, i, player.class, false); // Player's tent, not recruitable
        } else if (i <= player.recruitedCharacters.length + 1) {
            const character = player.recruitedCharacters[i-2];
            const isInParty = player.party.some(member => member.class === character.class);
            updateTentContent(tentElement, i, character.class, isInParty);
        } else {
            updateTentContent(tentElement, i, 'Empty', false);
        }
    }

    // Update merchant tent separately
    updateMerchantTent();

    // Update tent purchase buttons
    updateTentPurchaseButtons();

    // Update camp bank display
    updateCampBankDisplay();

    // Update party display
    updatePartyDisplay();
}

function createTentElement(number) {
    const tent = document.createElement('div');
    tent.id = `tent${number}`;
    tent.className = 'tent';
    tent.innerHTML = `
        <strong>Tent ${number}</strong><br>
        <span class="tent-occupant">Empty</span><br>
        <span class="party-status" style="display: none;">In Party</span><br>
        <button class="party-button" style="display: none;">Add to Party</button>
    `;
    return tent;
}

function updateTentContent(tentNumber, occupant) {
    const tentElement = document.getElementById(`tent${tentNumber}`);
    if (!tentElement) {
        console.error(`Tent element not found for tent ${tentNumber}`);
        return;
    }

    const occupantElement = tentElement.querySelector('.tent-occupant');
    if (occupantElement) {
        occupantElement.textContent = occupant;
    }

    // Only add party buttons for recruited characters (not the player's tent and not empty tents)
    if (tentNumber > 1 && occupant !== 'Empty') {
        const isInParty = player.party.some(member => member.class === occupant);
        
        let partyButton = tentElement.querySelector('.party-button');
        if (!partyButton) {
            partyButton = document.createElement('button');
            partyButton.className = 'party-button';
            tentElement.appendChild(partyButton);
        }

        partyButton.textContent = isInParty ? 'Remove from Party' : 'Add to Party';
        partyButton.onclick = () => togglePartyMembership(tentNumber);

        let partyStatus = tentElement.querySelector('.party-status');
        if (!partyStatus) {
            partyStatus = document.createElement('span');
            partyStatus.className = 'party-status';
            tentElement.appendChild(partyStatus);
        }

        partyStatus.textContent = isInParty ? 'In Party' : '';
        partyStatus.style.display = isInParty ? 'inline' : 'none';
    }
}

function updateTentPurchaseButtons() {
    for (let i = 2; i <= 5; i++) {
        const tentButton = document.getElementById(`${getTentNumberWord(i)}TentButton`);
        if (tentButton) {
            tentButton.style.display = i <= player.tents ? 'none' : 'block';
        }
    }
}

function updateCampBankDisplay() {
    const campBankDisplay = document.getElementById('campBankDisplay');
    if (campBankDisplay) {
        campBankDisplay.textContent = `Camp Bank: ${player.campBank} Gold`;
    } else {
        console.warn('Camp bank display element not found');
    }
}

function createTentElement(number) {
    const tent = document.createElement('div');
    tent.id = `tent${number}`;
    tent.className = 'tent';
    tent.innerHTML = `
        <strong>Tent ${number}</strong><br>
        <span class="tent-occupant">Empty</span><br>
        <span class="party-status" style="display: none;">In Party</span><br>
        <button class="party-button" style="display: none;">Add to Party</button>
    `;
    tent.style.width = '100px';
    tent.style.height = '100px';
    tent.style.border = '2px solid black';
    tent.style.display = 'inline-block';
    tent.style.margin = '5px';
    tent.style.padding = '5px';
    return tent;
}

function updateTentContent(tentNumber, occupant) {
    const tentElement = document.getElementById(`tent${tentNumber}`);
    if (tentElement) {
        const occupantElement = tentElement.querySelector('.tent-occupant');
        const partyButton = tentElement.querySelector('.party-button');
        const partyStatus = tentElement.querySelector('.party-status');
        
        if (occupantElement) {
            occupantElement.textContent = occupant;
        }
        
        if (tentNumber > 1 && occupant !== 'Empty') {
            const character = player.recruitedCharacters[tentNumber - 2];
            const isInParty = player.party.includes(character);

            partyButton.style.display = 'inline-block';
            partyButton.textContent = isInParty ? 'Remove from Party' : 'Add to Party';
            partyButton.onclick = () => togglePartyMembership(tentNumber);

            partyStatus.style.display = isInParty ? 'inline' : 'none';
            partyStatus.textContent = isInParty ? 'In Party' : '';
        } else {
            partyButton.style.display = 'none';
            partyStatus.style.display = 'none';
        }
    }
}

function addToParty(character) {
    if (player.party.length < 4) {  // Limit to 4 additional party members
        const partyMember = createPartyMember(character.class);
        player.party.push(partyMember);
        updatePartyDisplay();
        return true;
    } else {
        alert("Party is full! Remove a member before adding a new one.");
        return false;
    }
}

function removeFromParty(character) {
    const index = player.party.findIndex(char => char === character);
    if (index > -1) {
        player.party.splice(index, 1);
        updatePartyDisplay();
        return true;
    }
    return false;
}

function togglePartyMembership(tentNumber) {
    const characterIndex = tentNumber - 2; // Adjust for 0-based index and player's tent
    const character = player.recruitedCharacters[characterIndex];
    
    if (!character) {
        console.error(`No character found for tent ${tentNumber}`);
        return;
    }

    const partyIndex = player.party.findIndex(member => member.class === character.class);
    const isInParty = partyIndex !== -1;

    if (isInParty) {
        player.party.splice(partyIndex, 1);
        console.log(`Removed ${character.class} from party`);
    } else {
        if (player.party.length < 4) {
            player.party.push(character);
            console.log(`Added ${character.class} to party`);
        } else {
            alert("Party is full! Remove a member before adding a new one.");
            return;
        }
    }
    
    updateTentContent(tentNumber, character.class);
    updatePartyDisplay();
    saveGame();
}

function updateMerchantTent() {
    const commercialTentsRow = document.getElementById('commercialTentsRow');
    if (commercialTentsRow) {
        commercialTentsRow.innerHTML = '';
        if (player.merchantTent) {
            const merchantTent = createTentElement('Merchant');
            merchantTent.querySelector('.tent-occupant').textContent = 'Merchant';
            commercialTentsRow.appendChild(merchantTent);
        }
    }
}

        function continueDuelJourney() {
    console.log("Entering continueDuelJourney function");
    try {
        console.log("Hiding duel victory screen");
        hideDuelVictoryScreen();
        console.log("Setting gameState to exploring");
        gameState = 'exploring';
        console.log("Calling continueJourney");
        continueJourney();
    } catch (error) {
        console.error("Error in continueDuelJourney:", error);
        showErrorScreen(error);
    }
    console.log("Exiting continueDuelJourney function");
}

        function useEnemySpecialSkill(enemy) {
    console.log(`Enemy ${enemy.class} using special skill: ${enemy.specialSkill}`);
    switch(enemy.specialSkill) {
        // Warrior Skills
        case 'DoubleAttack':
            let damage1 = Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage;
            let damage2 = Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage;
            return damage1 + damage2;
        case 'StoneSkin':
            enemy.defending = true;
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage;
        case 'LifeAttack':
            let lifeDamage = Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage;
            enemy.health = Math.min(enemy.health + Math.floor(lifeDamage / 2), enemy.maxHealth);
            return lifeDamage;

        // Mage Skills
        case 'Thunder':
            player.stunnedTurns = 1;
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 2;
        case 'Fireball':
            player.burnedTurns = 2;
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 2;
        case 'HailStorm':
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 3;

        // Cleric Skills
        case 'HolyLight':
            player.exposed = true;
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 1;
        case 'LifeTransfer':
            let transferDamage = Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 1;
            enemy.health = Math.min(enemy.health + transferDamage, enemy.maxHealth);
            return transferDamage;
        case 'ShieldOfLight':
            enemy.shieldOfLight = 2;
            enemy.maxDamage += 2;
            return 0;

        // Rogue Skills
        case 'BlindShot':
            player.blind = 100;
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 1;
        case 'ToxicStab':
            const damage = Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 2;
            player.health -= damage;
            if (player.poisonCounter === 0) {
                player.poisonCounter = 1;
                console.log("Player has been poisoned!");
            }
            return damage;
        case 'PerfectParry':
            player.parryNextAttack = true;  // Set a flag for the player to parry the next attack
            console.log("Enemy used Perfect Parry, player's next attack will be parried");
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage + 1;

        default:
            console.log("Unknown enemy skill, using default attack");
            return Math.floor(Math.random() * (enemy.maxDamage - enemy.minDamage + 1)) + enemy.minDamage;
    }
}

        // Touch controls
        function handleTouch(event) {
    event.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const touch = event.changedTouches[0];
    const x = (touch.clientX - rect.left) * scaleX;
    const y = (touch.clientY - rect.top) * scaleY;
    
    // Check if touch is on an enemy
    for (let i = 0; i < enemies.length; i++) {
        const enemyX = 650;
        const enemyY = 180 + (i * 130);
        if (x >= enemyX && x <= enemyX + 50 && y >= enemyY && y <= enemyY + 50) {
            selectedEnemyIndex = i;
            drawGame(); // Redraw to show selection
            return;
        }
    }
    
    // If not on an enemy, check if touch is on a button
    if (isPointInButton(x, y, 'attackButton')) {
        playerAttack();
    } else if (isPointInButton(x, y, 'defendButton')) {
        playerDefend();
    } else if (isPointInButton(x, y, 'retreatButton')) {
        playerRetreat();
    } else if (isPointInButton(x, y, 'specialAttackButton')) {
        playerSpecialAttack();
    }
}

        // Add this event listener
        canvas.addEventListener('touchend', handleTouch);
        
        function isPointInButton(x, y, buttonId) {
            const button = document.getElementById(buttonId);
            const rect = button.getBoundingClientRect();
            return (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom);
        }
        
        // Only add touch listeners once
        canvas.addEventListener('touchend', handleTouch);
        
        function resizeGame() {
    const gameContainer = document.getElementById('gameContainer');
    const game = document.getElementById('gameCanvas');
    const gameAspectRatio = 800 / 500;
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    let newWidth, newHeight;

    if (windowWidth / windowHeight > gameAspectRatio) {
        newHeight = Math.min(windowHeight - 100, 500); // Cap at original height
        newWidth = newHeight * gameAspectRatio;
    } else {
        newWidth = Math.min(windowWidth, 800); // Cap at original width
        newHeight = newWidth / gameAspectRatio;
    }

    gameContainer.style.width = `${newWidth}px`;
    game.style.width = `${newWidth}px`;
    game.style.height = `${newHeight}px`;

    // Only change actual canvas dimensions on mobile
    if (isMobile()) {
        game.width = newWidth;
        game.height = newHeight;
    } else {
        game.width = 800;
        game.height = 500;
    }

    const ctx = game.getContext('2d');
    ctx.setTransform(game.width / 800, 0, 0, game.height / 500, 0, 0);

    if (gameState !== 'mainMenu') {
        drawGame();
    }
}
        
        function createMobileMenu() {
            const menu = document.createElement('div');
            menu.id = 'mobileMenu';
            menu.innerHTML = `
                <button id="menuToggle">☰</button>
                <div id="menuContent" style="display:none;">
                    <button id="attackBtn">Attack</button>
                    <button id="defendBtn">Defend</button>
                    <button id="specialBtn">Special</button>
                </div>
            `;
            document.body.appendChild(menu);
        
            document.getElementById('menuToggle').addEventListener('click', () => {
                const content = document.getElementById('menuContent');
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
            });
        }

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                   || window.innerWidth <= 768;
        }
        
        function saveGame() {
    const gameData = {
        player: {
            ...player,
            specialSkill: player.specialSkill ? { name: player.specialSkill.name } : null,
            merchantTent: player.merchantTent,
            recruitedCharacters: player.recruitedCharacters || [],
            party: (player.party || []).map(member => ({
                ...member,
                specialSkill: member.specialSkill ? { name: member.specialSkill.name } : null
            })),
            tents: player.tents || 1
        },
        enemies: enemies,
        gameState: gameState,
        currentStory: currentStory,
        treantEncountered: treantEncountered,
        duelEventsUnlocked: duelEventsUnlocked
    };
    localStorage.setItem('rpgGameSave', JSON.stringify(gameData));
	localStorage.setItem('merchantUpgrades', JSON.stringify(merchantUpgrades));
    console.log('Game saved successfully!');
    updateLoadGameButton();
}

function loadGame() {
    const savedGame = localStorage.getItem('rpgGameSave');
    if (savedGame) {
        const gameData = JSON.parse(savedGame);
        player = {
            ...gameData.player,
            recruitedCharacters: gameData.player.recruitedCharacters || [],
            party: gameData.player.party || [],
            tents: gameData.player.tents || 1
        };
		
		const savedMerchantUpgrades = localStorage.getItem('merchantUpgrades');
		if (savedMerchantUpgrades) {
			merchantUpgrades = JSON.parse(savedMerchantUpgrades);
		}
        enemies = gameData.enemies;
        gameState = gameData.gameState;
        currentStory = gameData.currentStory;
        treantEncountered = gameData.treantEncountered;
        duelEventsUnlocked = gameData.duelEventsUnlocked;

        // Reconstruct the special skills
        setupClassSkills();
        if (player.specialSkill) {
            player.specialSkill = player.specialSkills[player.specialSkill.name];
        }

        // Reconstruct special skills for party members
        player.party.forEach(member => {
            member.specialSkills = getClassSkills(member.class);
            if (member.specialSkill) {
                member.specialSkill = member.specialSkills[member.specialSkill.name];
            }
        });

        setupGameAfterLoad();
        startGame(false); // Call startGame with isNewGame set to false
        updateCampScreen(); // Update the camp screen
        updatePartyDisplay(); // New function to update party display
    } else {
        alert('No saved game found!');
    }
}

        function autoSave() {
            saveGame();
            console.log('Game auto-saved');
        }
        
        function hideAllScreens() {
			const screens = [
				'mainMenu', 'characterSelectScreen', 'gameContainer', 'gameCanvas', 
				'gameButtons', 'gameVictoryScreen', 'gameDefeatScreen', 
				'duelEventScreen', 'storyEventScreen', 'campScreen', 'duelVictoryScreen'
			];
			screens.forEach(screenId => {
				const screen = document.getElementById(screenId);
				if (screen) {
					screen.style.display = 'none';
				}
			});
		}
        
        function setupGameAfterLoad() {
            updateGameUI();
            resizeGame();
            if (gameState === 'playerTurn' || gameState === 'enemyTurn') {
                drawGame();
            }
            
            // Re-add event listener for special attack button
            const specialAttackButton = document.getElementById('specialAttackButton');
            specialAttackButton.removeEventListener('click', playerSpecialAttack);
            specialAttackButton.addEventListener('click', playerSpecialAttack);
        }
        
        function updateGameUI() {
            // Update special attack button
            if (player.specialSkill) {
                document.getElementById('specialAttackButton').style.display = 'inline-block';
                document.getElementById('specialAttackButton').textContent = player.specialSkill.name;
            } else {
                document.getElementById('specialAttackButton').style.display = 'none';
            }
            
            // Update other UI elements as needed
            updateCampMessage();
            updateTentButtons();
        }
        
        function updateLoadGameButton() {
            const loadGameButton = document.getElementById('loadGameButton');
            const savedGame = localStorage.getItem('rpgGameSave');
            loadGameButton.disabled = !savedGame;
        }
        
        function applyPoisonDamage() {
        if (player.poisonCounter && player.poisonCounter > 0) {
            const poisonDamage = player.poisonCounter;
            player.health -= poisonDamage;
            console.log(`Player takes ${poisonDamage} poison damage. Health reduced to ${player.health}`);
            damageDisplay.player.damage += poisonDamage;
            damageDisplay.player.x = 75;
            damageDisplay.player.y = 150;
            damageDisplay.player.alpha = 1;
            player.poisonCounter++;
            console.log(`Poison counter increased to ${player.poisonCounter}`);
    
            if (player.health <= 0) {
                console.log("Player died from poison");
                gameState = 'defeat';
                setTimeout(() => {
                    showDefeatScreen();
                }, 1000);
            }
        }
}

        function drawTurnIndicator() {
      ctx.save();
      
      const text = gameState === 'playerTurn' ? "Player's Turn" : "Enemy Turn";
      const fontSize = 24;
      ctx.font = `bold ${fontSize}px Arial`;
      
      const textWidth = ctx.measureText(text).width;
      const padding = 10;
      const rectWidth = textWidth + padding * 2;
      const rectHeight = fontSize + padding * 2;
      
      // Always position at the bottom center of the 800x500 game area
      const rectX = (800 - rectWidth) / 2;
      const rectY = 500 - rectHeight - 10; // 10px from the bottom
      
      ctx.fillStyle = "rgba(255, 0, 0, 0.3)";
      ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
      
      ctx.fillStyle = "white";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, 400, 500 - rectHeight / 2 - 10);
      
      ctx.restore();
  }
  
        function updateSpecialAttackButton() {
    //console.log("Updating special attack button");
    //console.log("Player class:", player.class);
    //console.log("Player level:", player.level);
    //console.log("Special skill unlocked:", player.specialSkillUnlocked);
    //console.log("Player special skill:", player.specialSkill);

    const specialAttackButton = document.getElementById('specialAttackButton');
    if (player.specialSkill && player.specialSkillUnlocked && player.level >= 3) {
        //console.log("Displaying special attack button");
        specialAttackButton.style.display = 'inline-block';
        if (player.specialAttackCooldown > 0) {
            specialAttackButton.textContent = `${player.specialSkill.name} (${player.specialAttackCooldown})`;
            specialAttackButton.disabled = true;
        } else {
            specialAttackButton.textContent = player.specialSkill.name;
            specialAttackButton.disabled = false;
        }
    } else {
        //console.log("Hiding special attack button");
        specialAttackButton.style.display = 'none';
    }
}
  
        function updateButtonStates() {
    const buttons = ['attackButton', 'defendButton', 'retreatButton', 'specialAttackButton'];
    const isPlayerTurn = gameState === 'playerTurn' || gameState === 'duel';

    buttons.forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.disabled = !isPlayerTurn;
            
            if (buttonId === 'specialAttackButton') {
                if (isPlayerTurn && player.specialAttackCooldown === 0 && player.specialSkill) {
                    button.classList.add('available');
                    button.classList.remove('cooldown');
                    button.disabled = false;
                } else {
                    button.classList.remove('available');
                    if (player.specialAttackCooldown > 0) {
                        button.classList.add('cooldown');
                    }
                    button.disabled = true;
                }
            }
        }
    });
}
  
        function updateShopButtons(isVictoryScreen = false) {
    const buttons = [
        { id: isVictoryScreen ? 'healingPotionButton' : 'campHealingPotionButton', item: 'healingPotion', cost: 100, name: 'Healing Potion', description: 'Heal 25 HP' },
        { id: isVictoryScreen ? 'expBoosterButton' : 'campExpBoosterButton', item: 'expBooster', cost: 200, name: 'EXP Booster', description: 'Double the next XP gained' },
        { id: isVictoryScreen ? 'antidoteButton' : 'campAntidoteButton', item: 'antidote', cost: 300, name: 'Antidote', description: 'Heals poison' },
        { id: isVictoryScreen ? 'lotusButton' : 'campLotusButton', item: 'lotus', cost: 500, name: 'Lotus of Experience', description: 'Grants 10 XP' },
        { id: isVictoryScreen ? 'redPillButton' : 'campRedPillButton', item: 'redPill', cost: 1000, name: 'Red Pill', description: '+1 Min Damage' }
    ];

    buttons.forEach(button => {
        const element = document.getElementById(button.id);
        if (element) {
            if (isVictoryScreen) {
                if (currentVictoryScreenPurchases[button.item]) {
                    element.disabled = true;
                    element.innerHTML = '<div class="button-content"><span class="item-name">Sold Out</span></div>';
                } else {
                    element.disabled = false;
                    element.innerHTML = `
                        <div class="button-content">
                            <span class="item-name">Buy ${button.name}</span>
                            <span class="gold-amount">${button.cost} Gold</span>
                        </div>
                    `;
                    element.onclick = () => buyVictoryItem(button.item, button.cost, button.name);
                }
            } else {
                // Camp shop logic remains unchanged
                if (player.purchasedItems && player.purchasedItems[button.item]) {
                    element.disabled = true;
                    element.innerHTML = '<div class="button-content"><span class="item-name">Sold Out</span></div>';
                } else {
                    element.disabled = false;
                    element.innerHTML = `
                        <div class="button-content">
                            <span class="item-name">Buy ${button.name}</span>
                            <span class="gold-amount">${button.cost} Gold</span>
                        </div>
                    `;
                    element.onclick = () => buyItemInCamp(button.item, button.cost, button.name);
                }
            }
        }
    });
}
  
        function handleMouseClick(event) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      
      let x, y;
      if (event.type === 'touchstart') {
        x = (event.touches[0].clientX - rect.left) * scaleX;
        y = (event.touches[0].clientY - rect.top) * scaleY;
      } else {
        x = (event.clientX - rect.left) * scaleX;
        y = (event.clientY - rect.top) * scaleY;
      }
      
      // Check if click/touch is on an enemy
      for (let i = 0; i < enemies.length; i++) {
          const enemyX = 650;
          const enemyY = 180 + (i * 130);
          if (x >= enemyX && x <= enemyX + 50 && y >= enemyY && y <= enemyY + 50) {
              selectedEnemyIndex = i;
              drawGame(); // Redraw to show selection
              return;
          }
      }
  }
  
  // Create mobile-friendly enemy selection overlay
        function createMobileEnemySelectionOverlay() {
    const overlay = document.createElement('div');
    overlay.id = 'mobileEnemySelectionOverlay';
    overlay.style.position = 'absolute';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.display = 'none'; // Initially hidden
    
    enemies.forEach((enemy, index) => {
      const button = document.createElement('div');
      button.style.position = 'absolute';
      button.style.left = '650px';
      button.style.top = `${180 + (index * 130)}px`;
      button.style.width = '50px';
      button.style.height = '50px';
      button.style.backgroundColor = 'rgba(255, 255, 255, 0.5)';
      button.style.border = '2px solid black';
      button.style.borderRadius = '50%';
      button.style.touchAction = 'manipulation';
      
      button.addEventListener('touchstart', (e) => {
        e.preventDefault();
        selectedEnemyIndex = index;
        drawGame();
      });
      
      overlay.appendChild(button);
    });
    
    document.body.appendChild(overlay);
  }
  
  
  canvas.addEventListener('click', handleMouseClick);
  
  // Call this function in drawGame and after each turn
  
  
  			function addDeveloperGold() {
  				player.gold += 1500;
  				updateGoldMessage();
  				updateVictoryScreenStats();
  				alert("Added 1500 gold to the player!");
  			}

        document.getElementById('developerGoldButton').onclick = addDeveloperGold;

        document.getElementById('loadGameButton').addEventListener('click', () => {
    loadGame();
    startGame(false);
      });
        document.getElementById('saveGameButton').onclick = function() {
            saveGame();
            const saveButton = this;
            saveButton.textContent = 'Saved!';
            setTimeout(() => {
                saveButton.textContent = 'Save Game';
            }, 2000);
        };

        window.addEventListener('resize', resizeGame);
        document.querySelectorAll('img').forEach(img => {
    console.log('Image found:', img.src, img.parentElement);
});

        // In-game skill buttons
        document.getElementById('thunderButton').addEventListener('click', () => selectSpecialSkill('Thunder'));
        document.getElementById('fireballButton').addEventListener('click', () => selectSpecialSkill('Fireball'));
        document.getElementById('hailStormButton').addEventListener('click', () => selectSpecialSkill('HailStorm'));
        document.getElementById('doubleAttackButton').addEventListener('click', () => selectSpecialSkill('DoubleAttack'));
        document.getElementById('stoneSkinButton').addEventListener('click', () => selectSpecialSkill('StoneSkin'));
        document.getElementById('lifeAttackButton').addEventListener('click', () => selectSpecialSkill('LifeAttack'));
        document.getElementById('holyLightButton').addEventListener('click', () => selectSpecialSkill('HolyLight'));
        document.getElementById('lifeTransferButton').addEventListener('click', () => selectSpecialSkill('LifeTransfer'));
        document.getElementById('shieldOfLightButton').addEventListener('click', () => selectSpecialSkill('ShieldOfLight'));
        document.getElementById('blindShotButton').addEventListener('click', () => selectSpecialSkill('BlindShot'));
        document.getElementById('toxicStabButton').addEventListener('click', () => selectSpecialSkill('ToxicStab'));
        document.getElementById('perfectParryButton').addEventListener('click', () => selectSpecialSkill('PerfectParry'));
        
        // Story event skill buttons
        document.getElementById('storyThunderButton').addEventListener('click', () => selectSpecialSkill('Thunder'));
        document.getElementById('storyFireballButton').addEventListener('click', () => selectSpecialSkill('Fireball'));
        document.getElementById('storyHailStormButton').addEventListener('click', () => selectSpecialSkill('HailStorm'));
        document.getElementById('storyDoubleAttackButton').addEventListener('click', () => selectSpecialSkill('DoubleAttack'));
        document.getElementById('storyStoneSkinButton').addEventListener('click', () => selectSpecialSkill('StoneSkin'));
        document.getElementById('storyLifeAttackButton').addEventListener('click', () => selectSpecialSkill('LifeAttack'));
        document.getElementById('storyHolyLightButton').addEventListener('click', () => selectSpecialSkill('HolyLight'));
        document.getElementById('storyLifeTransferButton').addEventListener('click', () => selectSpecialSkill('LifeTransfer'));
        document.getElementById('storyShieldOfLightButton').addEventListener('click', () => selectSpecialSkill('ShieldOfLight'));
        document.getElementById('storyBlindShotButton').addEventListener('click', () => selectSpecialSkill('BlindShot'));
        document.getElementById('storyToxicStabButton').addEventListener('click', () => selectSpecialSkill('ToxicStab'));
        document.getElementById('storyPerfectParryButton').addEventListener('click', () => selectSpecialSkill('PerfectParry'));


        // Add event listeners for main menu and gameplay buttons
        document.getElementById('startGameButton').addEventListener('click', () => startGame(true));
        //document.getElementById('resetButton').addEventListener('click', developerReset); // Add event listener for reset button

        
        
        document.getElementById('secondTentButton').addEventListener('click', () => buyTent(2, 1500));
        document.getElementById('thirdTentButton').addEventListener('click', () => buyTent(3, 2000));
        document.getElementById('fourthTentButton').addEventListener('click', () => buyTent(4, 2500));
        document.getElementById('fifthTentButton').addEventListener('click', () => buyTent(5, 3000));
        document.getElementById('merchantTentButton').addEventListener('click', buyMerchantTent);

        // Add event listeners for victory screen buttons
        document.getElementById('continueJourneyButton').onclick = continueJourney;
        document.getElementById('returnToCampButton').addEventListener('click', returnToCamp);
        //document.getElementById('developerButton').addEventListener('click', () => {
           // player.level = 3;
            //checkLevelUp();
            //updateVictoryScreenStats();
        //});
        //document.getElementById('developerButton5').addEventListener('click', () => {
           // player.level = 5;
           // checkLevelUp();
            //updateVictoryScreenStats();
        //});

        // Add event listeners for defeat screen buttons
        document.getElementById('tryAgainButton').addEventListener('click', () => {
            hideDefeatScreen();
            resetGame();
        });

        // Add event listeners for camp screen buttons
        document.getElementById('storeGoldButton').addEventListener('click', storeGoldInCamp);
        document.getElementById('continueJourneyFromCampButton').onclick = function() {
			console.log("Continue journey from camp button clicked");
			continueJourneyFromCamp();
		};

        // Add event listeners for story event screen buttons
        document.getElementById('storyChoice1Button').addEventListener('click', () => {
            console.log("storyChoice1Button clicked");
            if (currentStory === STORY_OLD_MAN) {
                handleOldManChoice1();
            } else if (currentStory === STORY_TREANT) {
                handleTreePoke1();
            }
        });
        document.getElementById('storyChoice2Button').addEventListener('click', () => {
            console.log("storyChoice2Button clicked");
            if (currentStory === STORY_OLD_MAN) {
                handleOldManChoice2();
            } else if (currentStory === STORY_TREANT) {
                handleTreeAsk();
            }
        });
        document.getElementById('storyChoice3Button').addEventListener('click', () => {
            console.log("storyChoice3Button clicked");
            if (currentStory === STORY_OLD_MAN) {
                handleOldManChoice3();
            } else if (currentStory === STORY_TREANT) {
                handleTreeLeave();
            }
        });
        document.getElementById('continueJourneyFromStoryButton').onclick = continueJourney;
    </script>
</body>
</html>