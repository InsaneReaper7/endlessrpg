<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raid Boss Card Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    <style>
	
		.main-menu {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #1a1a1a;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			z-index: 2000;
		}

		.game-title {
			font-family: 'Cinzel', serif; /* We'll import this font */
			font-size: 6rem;
			color: #e74c3c;
			text-shadow: 0 0 10px rgba(231, 76, 60, 0.5),
						 0 0 20px rgba(231, 76, 60, 0.3),
						 0 0 30px rgba(231, 76, 60, 0.2);
			animation: titlePulse 3s ease-in-out infinite;
			margin-bottom: 2rem;
			letter-spacing: 4px;
		}

		.press-any-key {
			font-family: Arial, sans-serif;
			font-size: 1.5rem;
			color: #fff;
			opacity: 0.8;
			animation: textPulse 1.5s ease-in-out infinite;
		}
		.main-menu {
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background-color: #1a1a1a;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			z-index: 2000;
			cursor: pointer;
			user-select: none; /* Prevent text selection */
		}

		.main-menu:hover .press-any-key {
			opacity: 1; /* Full opacity on hover */
		}

		.game-title {
			font-family: 'Cinzel', serif;
			font-size: 6rem;
			color: #e74c3c;
			text-shadow: 0 0 10px rgba(231, 76, 60, 0.5),
						 0 0 20px rgba(231, 76, 60, 0.3),
						 0 0 30px rgba(231, 76, 60, 0.2);
			animation: titlePulse 3s ease-in-out infinite;
			margin-bottom: 2rem;
			letter-spacing: 4px;
		}

		.press-any-key {
			font-family: Arial, sans-serif;
			font-size: 1.5rem;
			color: #fff;
			opacity: 0.8;
			animation: textPulse 1.5s ease-in-out infinite;
			transition: opacity 0.3s ease;
		}

		@keyframes titlePulse {
			0% {
				transform: scale(1);
				text-shadow: 0 0 10px rgba(231, 76, 60, 0.5),
							 0 0 20px rgba(231, 76, 60, 0.3),
							 0 0 30px rgba(231, 76, 60, 0.2);
			}
			50% {
				transform: scale(1.05);
				text-shadow: 0 0 15px rgba(231, 76, 60, 0.6),
							 0 0 25px rgba(231, 76, 60, 0.4),
							 0 0 35px rgba(231, 76, 60, 0.3);
			}
			100% {
				transform: scale(1);
				text-shadow: 0 0 10px rgba(231, 76, 60, 0.5),
							 0 0 20px rgba(231, 76, 60, 0.3),
							 0 0 30px rgba(231, 76, 60, 0.2);
			}
		}

		@keyframes textPulse {
			0% { opacity: 0.4; }
			50% { opacity: 0.8; }
			100% { opacity: 0.4; }
		}
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: white;
        }
        .game-container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 10px;
            background-color: #333;
            border-radius: 8px;
        }
        .enemies-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        .damage-number {
			position: absolute;
			color: #ff4444;
			font-weight: bold;
			font-size: 1.5em;
			animation: floatUp 2s forwards;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
			pointer-events: none;
		}

		@keyframes floatUp {
			0% {
				opacity: 1;
				transform: translateY(0);
			}
			100% {
				opacity: 0;
				transform: translateY(-50px);
			}
		}

		.enemy-card {
			position: relative;
            background-color: #661111;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .enemy-card.targetable {
            border-color: #4CAF50;
            cursor: pointer;
            animation: pulse 1.5s infinite;
        }
        .enemy-card.targetable:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }
		.boss-card {
			background-color: #800000;
			padding: 20px;
			border-radius: 8px;
			text-align: center;
			position: relative;
			border: 2px solid #ff4444;
			box-shadow: 0 0 15px rgba(255, 68, 68, 0.3);
		}

		.boss-intent {
			margin-top: 10px;
			padding: 8px;
			border-radius: 4px;
			font-weight: bold;
		}

		.intent-attack {
			background-color: rgba(255, 68, 68, 0.2);
			color: #ff4444;
		}

		.intent-spawn {
			background-color: rgba(76, 175, 80, 0.2);
			color: #4CAF50;
		}

		.intent-weaken {
			background-color: rgba(139, 0, 0, 0.2);
			color: #8b0000;
		}

		.status-effect.weakened {
			background-color: #8b0000;
			color: white;
		}

		.phase-transition {
			animation: pulsate 1s ease-in-out infinite;
		}

		@keyframes pulsate {
			0% { transform: scale(1); }
			50% { transform: scale(1.05); }
			100% { transform: scale(1); }
		}
        .hand-container {
            margin-top: auto;
            padding: 20px;
            background-color: #2a2a2a;
            border-radius: 8px 8px 0 0;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }
        .card {
            background-color: #444;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }
        .card:hover:not(.disabled) {
            transform: translateY(-5px);
            border-color: #4CAF50;
        }
        .card.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        .health-bar {
            width: 100%;
            height: 20px;
            background-color: #666;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }
        .health-bar-fill {
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s ease-in-out;
        }
        .energy-orb {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 5px;
            background-color: #3498db;
        }
        .energy-orb.empty {
            background-color: #666;
        }
        .status-effect {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 4px;
            margin: 0 5px;
            font-size: 14px;
        }
        .empower {
            background-color: #f1c40f;
            color: black;
        }
        .counter {
            background-color: #3498db;
        }
        .targeting-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #4CAF50;
            padding: 10px 20px;
            border-radius: 4px;
            z-index: 1000;
			transition: opacity 0.3s;
			color: white;
			font-weight: bold;
        }
		.victory-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .victory-content {
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            max-width: 600px;
            width: 90%;
        }

        .rewards-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .reward-card {
            background-color: #444;
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .reward-card:hover {
            transform: translateY(-5px);
            border-color: #4CAF50;
            box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
        }

        .round-counter {
            background-color: #4a4a4a;
            padding: 10px 20px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 1.2em;
        }
		.defeat-text {
			color: #ff4444;
			font-size: 2em;
			text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
			animation: pulse 2s infinite;
		}

		@keyframes pulse {
			0% { opacity: 1; }
			50% { opacity: 0.7; }
			100% { opacity: 1; }
		}
		
		.energy-gain {
			position: fixed;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			color: #3498db;
			font-size: 24px;
			animation: energyGain 1s forwards;
			z-index: 1000;
		}

		@keyframes energyGain {
			0% {
				opacity: 0;
				transform: translate(-50%, -50%) scale(0.5);
			}
			50% {
				opacity: 1;
				transform: translate(-50%, -50%) scale(1.2);
			}
			100% {
				opacity: 0;
				transform: translate(-50%, -50%) scale(1);
			   }
		}
		
		.round-counter {
			background-color: #4a4a4a;
			padding: 10px 20px;
			border-radius: 4px;
			font-weight: bold;
			font-size: 1.2em;
			margin: 0 20px;  /* Add some spacing on sides */
		}
		
		.damage-number {
			position: absolute;
			color: #ff4444;
			font-weight: bold;
			font-size: 1.5em;
			animation: floatUp 2s forwards;
			text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
			pointer-events: none;
		}

		@keyframes floatUp {
			0% {
				opacity: 1;
				transform: translateY(0);
			}
			100% {
				opacity: 0;
				transform: translateY(-50px);
			}
		}

		.enemy-card {
			position: relative;
			/* ... rest of your existing enemy-card styles ... */
		}
		.status-effect.weakened {
			background-color: #8b0000;
			color: white;
			animation: pulse 2s infinite;
		}

		@keyframes pulse {
			0% { opacity: 1; }
			50% { opacity: 0.7; }
			100% { opacity: 1; }
		}
		

				
    </style>
</head>
<body>
    <div id="game-root"></div>
    <script type="text/javascript">
        const { useState, useEffect } = React;
		
		const Game = () => {
            // Game state
            const [playerHealth, setPlayerHealth] = useState(100);
            const [playerEnergy, setPlayerEnergy] = useState(3);
            const [hand, setHand] = useState([]);
            const [deck, setDeck] = useState([]);
            const [discardPile, setDiscardPile] = useState([]);
            const [enemies, setEnemies] = useState([]);
            const [empowerActive, setEmpowerActive] = useState(false);
            const [counterActive, setCounterActive] = useState(false);
            const [selectedCard, setSelectedCard] = useState(null);
            const [selectedCardIndex, setSelectedCardIndex] = useState(null);
            const [isTargeting, setIsTargeting] = useState(false);
			const [round, setRound] = useState(1);
            const [showVictory, setShowVictory] = useState(false);
            const [rewardOptions, setRewardOptions] = useState([]);
			const [gameStarted, setGameStarted] = useState(false);
			const [gameOver, setGameOver] = useState(false);
			const [showEnergyGain, setShowEnergyGain] = useState(false);
			const [exhaustedCards, setExhaustedCards] = useState([]);
			const [discountedCards, setDiscountedCards] = useState(new Map());
			const BASE_DECK_SIZE = 8; // Initial deck size, update this to match your initial deck size
			const [totalDeckSize, setTotalDeckSize] = useState(0);
			const [isProcessingFreshStart, setIsProcessingFreshStart] = useState(false);
			const [freshStartInProgress, setFreshStartInProgress] = useState(false);
			const getTotalCards = () => deck.length + hand.length + discardPile.length + exhaustedCards.length;
			const [cardIdCounter, setCardIdCounter] = useState(0);
			const [statusMessage, setStatusMessage] = useState('');
			const [showStatusMessage, setShowStatusMessage] = useState(false);
			const [showMainMenu, setShowMainMenu] = useState(true);
			const [currentScreen, setCurrentScreen] = useState('splash'); // 'splash', 'menu', 'game', 'talents'
			const [showPreBossFight, setShowPreBossFight] = useState(false);
			const [maxHealth, setMaxHealth] = useState(100);
			const [specialRewardOptions, setSpecialRewardOptions] = useState([]);
			const [showSpecialRewards, setShowSpecialRewards] = useState(false);
			const [showCardRemoval, setShowCardRemoval] = useState(false);
			const [playerWeakened, setPlayerWeakened] = useState(false);
			const [bossLastAction, setBossLastAction] = useState(null);
			const [knowledgePoints, setKnowledgePoints] = useState(() => {
			  const savedPoints = localStorage.getItem('knowledgePoints');
			  return savedPoints ? parseInt(savedPoints) : 0;
			});

			const [skillPoints, setSkillPoints] = useState(() => {
			  const savedPoints = localStorage.getItem('skillPoints');
			  return savedPoints ? parseInt(savedPoints) : 0;
			});

			// Helper to create a unique card instance
			const createCardInstance = (cardType) => ({
				id: cardIdCounter + 1,
				type: cardType
			});
			
			const bossEnemy = {
				health: 150,
				maxHealth: 150,
				intent: 'spawn',
				damage: 15,
				damageNumbers: [],
				isBoss: true,
				turnsUntilSpawn: 2,
				phase: 1,
				spawnedMinions: 0
			};

			const minionEnemy = {
				health: 12,
				maxHealth: 12,
				intent: 'attack',
				damage: 4,
				damageNumbers: [],
				isMinion: true
			};

			// Add this helper function after your constants
			const calculateDamage = (baseDamage, empowered = false) => {
				let damage = baseDamage;
				if (empowered) {
					damage += 2;
				}
				if (playerWeakened) {
					damage = Math.max(1, damage - 1); // Ensure damage doesn't go below 1
				}
				return damage;
			};

			// Add this helper function as well
			const getAvailableBossActions = (lastAction) => {
				const allActions = ['attack', 'spawn', 'weaken'];
				return allActions.filter(action => action !== lastAction);
			};
			
			
			
            // Card definitions
            const cardTypes = {
		multiAttack: {
			name: 'Multi-Attack',
			cost: 2,
			description: 'Hit all enemies for 3 damage',
			needsTarget: false,
			effect: (enemies) => {
				const baseDamage = 3;
				const damage = calculateDamage(baseDamage, empowerActive);
				
				return enemies.map(enemy => ({
					...enemy,
					health: Math.max(0, enemy.health - damage),
					damageNumbers: [
						...enemy.damageNumbers.filter(dn => Date.now() - dn.createdAt < 2000),
						createDamageNumber(damage, Date.now())
					]
				}));
			}
		},
		singleAttack: {
			name: 'Single Attack',
			cost: 1,
			description: 'Hit one enemy for 5 damage',
			needsTarget: true,
			effect: (enemies, targetIndex) => {
				const baseDamage = 5;
				const damage = calculateDamage(baseDamage, empowerActive);
				
				return enemies.map((enemy, index) => {
					if (index === targetIndex) {
						return {
							...enemy,
							health: Math.max(0, enemy.health - damage),
							damageNumbers: [
								...enemy.damageNumbers.filter(dn => Date.now() - dn.createdAt < 2000),
								createDamageNumber(damage, Date.now())
							]
						};
					}
					return enemy;
				});
			}
		},
		empower: {
			name: 'Empower',
			cost: 1,
			description: 'Next attack deals +2 damage (persists until an attack is used)',
			needsTarget: false,
			effect: () => {
				setEmpowerActive(true);
				console.log('Empower activated');
				return enemies;
			}
		},
	counter: {
		name: 'Counter',
		cost: 2,
		description: 'Block and return the next enemy attack back to them',
		needsTarget: false,
		effect: () => {
			// Since counter doesn't deal immediate damage, we just set it active
			setCounterActive(true);
			return enemies;
		}
		// Note: The actual damage reflection happens in your endTurn function
		// You'll want to update that to show damage numbers when counter triggers
	},

	heavyAttack: {
        name: 'Heavy Attack',
        cost: 2,
        description: 'Deal 8 damage to one enemy',
        needsTarget: true,
        effect: (enemies, targetIndex) => {
            const baseDamage = 8;
            const damage = calculateDamage(baseDamage, empowerActive);
            
            return enemies.map((enemy, index) => 
                index === targetIndex 
                    ? {
                        ...enemy,
                        health: Math.max(0, enemy.health - damage),
                        damageNumbers: [
                            ...enemy.damageNumbers.filter(dn => Date.now() - dn.createdAt < 2000),
                            createDamageNumber(damage, Date.now())
                        ]
                    }
                    : enemy
            );
        }
    },

	quickStrike: {
        name: 'Quick Strike',
        cost: 1,
        description: 'Deal 3 damage to one enemy and draw a card',
        needsTarget: true,
        effect: (enemies, targetIndex) => {
            const baseDamage = 3;
            const damage = calculateDamage(baseDamage, empowerActive);
            
            const updatedEnemies = enemies.map((enemy, index) => 
                index === targetIndex 
                    ? {
                        ...enemy,
                        health: Math.max(0, enemy.health - damage),
                        damageNumbers: [
                            ...enemy.damageNumbers.filter(dn => Date.now() - dn.createdAt < 2000),
                            createDamageNumber(damage, Date.now())
                        ]
                    }
                    : enemy
            );

            // Handle drawing a card
            setTimeout(() => {
                if (deck.length > 0) {
                    const cardToDraw = deck[0];
                    setDeck(prev => prev.slice(1));
                    setHand(prev => [...prev, cardToDraw]);
                } else if (discardPile.length > 0) {
                    const shuffledDiscard = shuffleArray([...discardPile]);
                    const cardToDraw = shuffledDiscard[0];
                    setDeck(prev => shuffledDiscard.slice(1));
                    setDiscardPile([]);
                    setHand(prev => [...prev, cardToDraw]);
                }
            }, 0);

            return updatedEnemies;
        }
    },
     doubleEnergy: {
        name: 'Energize',
        cost: 1,
        description: 'Gain 2 Energy',
        needsTarget: false,
        effect: function() {  // Changed to regular function syntax
            const updatedEnergy = playerEnergy + 1;
            setPlayerEnergy(updatedEnergy);
            setShowEnergyGain(true);
            setTimeout(() => setShowEnergyGain(false), 1000);
            return enemies;
        }
	},
	// Add the Lucky Draw card type
		luckyDraw: {
			name: 'Lucky Draw',
			cost: 2,
			description: 'Draw a card and reduce its cost to 0 for this turn',
			needsTarget: false,
			effect: function() {
				// First check if we can draw from deck
				if (deck.length > 0) {
					const cardToDraw = deck[0];
					setDeck(prev => prev.slice(1));
					// Add to hand and set zero cost
					setHand(prev => [...prev, cardToDraw]);
					setDiscountedCards(prev => {
						const newDiscounts = new Map(prev);
						newDiscounts.set(cardToDraw.id, "zero");
						return newDiscounts;
					});
				}
				// If deck is empty, try drawing from shuffled discard pile
				else if (discardPile.length > 0) {
					const shuffledDiscard = shuffleArray([...discardPile]);
					const cardToDraw = shuffledDiscard[0];
					setDeck(prev => shuffledDiscard.slice(1));
					setDiscardPile([]);
					setHand(prev => [...prev, cardToDraw]);
					setDiscountedCards(prev => {
						const newDiscounts = new Map(prev);
						newDiscounts.set(cardToDraw.id, "zero");
						return newDiscounts;
					});
				}
				return enemies;
			}
		},
		healthSiphon: {
			name: 'Health Siphon',
			cost: 2,
			description: 'Deal 3 damage and heal for the damage dealt',
			needsTarget: true,
			effect: (enemies, targetIndex) => {
				const damage = empowerActive ? 5 : 3;
				
				return enemies.map((enemy, index) => {
					if (index === targetIndex) {
						const actualDamage = Math.min(enemy.health, damage);
						setPlayerHealth(prev => Math.min(100, prev + actualDamage));
						return {
							...enemy,
							health: Math.max(0, enemy.health - damage),
							damageNumbers: [
								...enemy.damageNumbers.filter(dn => Date.now() - dn.createdAt < 2000),
								createDamageNumber(damage, Date.now())
							]
						};
					}
					return enemy;
				});
			}
		},

		divineBlessing: {
			name: 'Divine Blessing',
			cost: 1,
			description: 'Heal 10 HP. Exhaust.',
			needsTarget: false,
			exhausts: true,
			effect: (enemies) => {
				// Heal player
				setPlayerHealth(prev => Math.min(100, prev + 10));
				return enemies;
			}
		},
	
		
		freshStart: {
			name: 'Fresh Start',
			cost: 3,
			description: 'Discard your hand, draw 3 cards, and gain 3 energy',
			needsTarget: false,
			effect: function(enemies, handIndex) {
				// Make sure hand and index are valid
				if (handIndex === undefined || !hand[handIndex]) {
					console.error('Fresh Start: Invalid hand index');
					return enemies;
				}

				// Get Fresh Start and other cards
				const freshStartCard = hand[handIndex];
				const otherCards = hand.filter((_, index) => index !== handIndex);

				// Move all hand cards to discard
				const newDiscard = [...discardPile, freshStartCard, ...otherCards];
				setDiscardPile(newDiscard);
				setHand([]);

				// Initial draw from current deck
				const cardsNeeded = 3;
				let newHand = [];
				let remainingDeck = [...deck];

				// Draw as many cards as we can from current deck
				if (remainingDeck.length > 0) {
					const cardsFromDeck = remainingDeck.slice(0, Math.min(cardsNeeded, remainingDeck.length));
					newHand = [...cardsFromDeck];
					remainingDeck = remainingDeck.slice(cardsFromDeck.length);
				}

				// If we still need more cards and have cards in discard, shuffle and draw
				if (newHand.length < cardsNeeded && newDiscard.length > 0) {
					const shuffledDiscard = shuffleArray([...newDiscard]);
					const remainingCardsToDraw = cardsNeeded - newHand.length;
					const cardsFromDiscard = shuffledDiscard.slice(0, remainingCardsToDraw);
					const remainingDiscard = shuffledDiscard.slice(remainingCardsToDraw);

					newHand = [...newHand, ...cardsFromDiscard];
					remainingDeck = [...remainingDeck, ...remainingDiscard];
					setDiscardPile([]);
				}

				// Update game state
				setDeck(remainingDeck);
				setHand(newHand);
				setPlayerEnergy(prev => prev + 3);

				return enemies;
			}
		},
		recycle: {
			name: 'Recycle',
			cost: 1,
			description: 'Draw a random card from your discard pile',
			needsTarget: false,
			effect: function(enemies, handIndex) {
				// Log initial state
				console.log('Recycle Before:', {
					discardSize: discardPile.length,
					discardCards: discardPile.map(c => `${c.type}(${c.id})`),
					handSize: hand.length
				});

				if (discardPile.length === 0) {
					// Show message if discard is empty
					setStatusMessage('No cards in discard pile to draw!');
					setShowStatusMessage(true);
					setTimeout(() => setShowStatusMessage(false), 2000);
					return enemies;
				}

				// Select random card from discard
				const randomIndex = Math.floor(Math.random() * discardPile.length);
				const drawnCard = discardPile[randomIndex];
				
				// Create new discard pile without the drawn card
				const newDiscard = [...discardPile];
				newDiscard.splice(randomIndex, 1);
				
				// Log operation
				console.log('Recycle Operation:', {
					drawnCard: `${drawnCard.type}(${drawnCard.id})`,
					remainingDiscard: newDiscard.length,
					newHandSize: hand.length + 1
				});

				// Update game state
				setDiscardPile(newDiscard);
				setHand(prev => [...prev, drawnCard]);
				
				return enemies;
			}
		},
		discount: {
			name: 'Discount',
			cost: 2,
			description: 'Reduce the energy cost of all cards in hand by 1',
			needsTarget: false,
			effect: function() {
				// Create a new Map of discounted costs for all cards in hand using card IDs
				const newDiscounts = new Map();
				hand.forEach(card => {
					newDiscounts.set(card.id, "reduced");
				});
				setDiscountedCards(newDiscounts);
				return enemies;
			}
		},

		doubleHit: {
			name: 'Double Hit',
			cost: 2,
			description: 'Hit the same enemy twice for 2-5 damage each hit',
			needsTarget: true,
			effect: (enemies, targetIndex) => {
				const hit1 = Math.floor(Math.random() * 4) + 2;
				const hit2 = Math.floor(Math.random() * 4) + 2;
				const damage1 = empowerActive ? hit1 + 2 : hit1;
				const damage2 = empowerActive ? hit2 + 2 : hit2;
				
				return enemies.map((enemy, index) => {
					if (index === targetIndex) {
						const afterFirstHit = Math.max(0, enemy.health - damage1);
						const afterSecondHit = Math.max(0, afterFirstHit - damage2);
						return {
							...enemy,
							health: afterSecondHit,
							damageNumbers: [
								...enemy.damageNumbers.filter(dn => Date.now() - dn.createdAt < 2000),
								createDamageNumber(damage1, Date.now()),
								createDamageNumber(damage2, Date.now() + 1)
							]
						};
					}
					return enemy;
				});
			}
		}
	}; // Close cardTypes with semicolon

	// Then define talentCardUnlocks as a separate constant
	const talentCardUnlocks = {
		'cardDraw1': {
			name: 'Generous Draw',
			cost: 1,
			description: 'Draw 2 cards',
			needsTarget: false,
			effect: function(enemies) {
				if (deck.length > 0) {
					const cardsToDraw = Math.min(2, deck.length);
					const newCards = deck.slice(0, cardsToDraw);
					setHand(prev => [...prev, ...newCards]);
					setDeck(prev => prev.slice(cardsToDraw));
				}
				return enemies;
			}
		}
	};

	// Then define the helper functions
	const unlockTalentCard = (nodeId) => {
		const cardToUnlock = talentCardUnlocks[nodeId];
		if (cardToUnlock) {
			cardTypes[nodeId] = cardToUnlock;
		}
	};

	const initializeUnlockedCards = () => {
		const savedUnlocked = JSON.parse(localStorage.getItem('unlockedNodes') || '[]');
		savedUnlocked.forEach(nodeId => {
			if (talentCardUnlocks[nodeId]) {
				cardTypes[nodeId] = talentCardUnlocks[nodeId];
			}
		});
	};
			
			 const TalentsScreen = () => {
			  const centerX = 800;
			  const centerY = 600;
			  
			  // State declarations
			  const [showConfirmation, setShowConfirmation] = useState(false);
			  const [selectedNode, setSelectedNode] = useState(null);
			  const [unlockedNodes, setUnlockedNodes] = useState(() => {
				const saved = localStorage.getItem('unlockedNodes');
				return saved ? JSON.parse(saved) : [];
			  });
			  const [mapPosition, setMapPosition] = useState({
				x: window.innerWidth / 2 - centerX,
				y: window.innerHeight / 2 - centerY
			  });
			  const [isDragging, setIsDragging] = useState(false);
			  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
			  
			    const resetPosition = () => {
					setMapPosition({
					  x: window.innerWidth / 2 - centerX,
					  y: window.innerHeight / 2 - centerY
					});
				  };

				  // Add resize effect to handle window resizing
				  useEffect(() => {
					const handleResize = () => {
					  resetPosition();
					};
					
					window.addEventListener('resize', handleResize);
					return () => window.removeEventListener('resize', handleResize);
				  }, []);

			  // createPathNodes function should go here
			  const createPathNodes = (startX, startY, direction, count) => {
				const nodes = [];
				const spacing = 80;
				let dx = 0, dy = 0;
				
				switch(direction) {
				  case 'north': dy = -spacing; break;
				  case 'south': dy = spacing; break;
				  case 'east': dx = spacing; break;
				  case 'west': dx = -spacing; break;
				}

				// Add the identifier node first
				nodes.push({
				  id: 'cardDrawIdentifier',
				  x: startX,
				  y: startY,
				  isIdentifier: true
				});

				// Then add all the actual talent nodes
				for(let i = 1; i <= count; i++) {
				  nodes.push({
					id: `cardDraw${i}`,
					x: startX + (dx * i),
					y: startY + (dy * i)
				  });
				}
				return nodes;
			  };

			  const cardDrawPath = createPathNodes(centerX, centerY, 'north', 10);

			  // Then the rest of your component functions
			  const handleMouseDown = (e) => {
				setIsDragging(true);
				setDragStart({ x: e.clientX - mapPosition.x, y: e.clientY - mapPosition.y });
			  };

				const handleMouseMove = (e) => {
				  if (!isDragging) return;
				  setMapPosition({
					x: e.clientX - dragStart.x,
					y: e.clientY - dragStart.y
				  });
				};

				const handleMouseUp = () => setIsDragging(false);

				const handleNodeClick = (e, node) => {
				  e.stopPropagation();
				  if (!isDragging) {
					const nodeNumber = parseInt(node.id.replace('cardDraw', ''));
					const isAvailable = nodeNumber === 1 || unlockedNodes.includes(`cardDraw${nodeNumber - 1}`);
					
					if (isAvailable && !unlockedNodes.includes(node.id)) {
					  setSelectedNode(node);
					  setShowConfirmation(true);
					}
				  }
				};

				const handlePurchase = () => {
					if (skillPoints > 0) {
						const nodeNumber = parseInt(selectedNode?.id.replace('cardDraw', ''));
						const newUnlocked = [...unlockedNodes, selectedNode.id];
						
						// Unlock the card if it's available
						unlockTalentCard(selectedNode.id);
						
						// Show unlock message
						setStatusMessage(`New card unlocked: ${talentCardUnlocks[selectedNode.id]?.name || 'Card'}!`);
						setShowStatusMessage(true);
						setTimeout(() => setShowStatusMessage(false), 2000);
						
						// Update state
						setUnlockedNodes(newUnlocked);
						localStorage.setItem('unlockedNodes', JSON.stringify(newUnlocked));
						setSkillPoints(prev => {
							const newPoints = prev - 1;
							localStorage.setItem('skillPoints', newPoints.toString());
							return newPoints;
						});
					}
					setShowConfirmation(false);
				};

				const NodePopup = () => React.createElement('div', { className: 'victory-overlay' },
				  React.createElement('div', {
					className: 'victory-content',
					style: {
					  maxWidth: '400px',
					  backgroundColor: '#1a1a1a',
					  border: '2px solid #4CAF50'
					}
				  }, [
					React.createElement('h3', {
					  key: 'title',
					  style: {
						color: '#4CAF50',
						marginBottom: '20px',
						fontSize: '24px',
						textShadow: '0 0 10px rgba(76, 175, 80, 0.3)'
					  }
					}, selectedNode?.id === 'cardDraw1' ? 'Card Draw Talent Tree' : `Level ${parseInt(selectedNode?.id.replace('cardDraw', ''))}`),
					React.createElement('p', {
					  key: 'description',
					  style: {
						fontSize: '1.2em',
						marginBottom: '30px',
						color: '#fff',
						lineHeight: '1.4'
					  }
					}, [
					  'Generous Draw - Cost 1 - Draw 2 cards',
					  'First card drawn each turn costs 1 less',
					  'Draw 1 additional card when your deck runs out',
					  'Start each combat with 4 cards instead of 3',
					  'Draw 1 card when you play 3 cards in a turn',
					  'Your maximum hand size is increased by 1',
					  'First card drawn each turn is from the top 2 cards',
					  'Draw 1 card when you exhaust a card',
					  'Draw 2 additional cards at the start of boss fights',
					  'Once per combat, draw until you have 5 cards'
					][parseInt(selectedNode?.id.replace('cardDraw', '')) - 1]),
					React.createElement('div', {
					  key: 'buttons',
					  style: {
						display: 'flex',
						justifyContent: 'space-around',
						marginTop: '30px'
					  }
					}, [
					  React.createElement('button', {
						key: 'purchase',
						onClick: handlePurchase,
						className: 'button',
						style: {
						  backgroundColor: skillPoints > 0 ? '#4CAF50' : '#666',
						  cursor: skillPoints > 0 ? 'pointer' : 'not-allowed',
						  padding: '12px 30px',
						  fontSize: '1.1em',
						  transition: 'all 0.3s ease'
						},
						disabled: skillPoints <= 0
					  }, 'Purchase'),
					  React.createElement('button', {
						key: 'cancel',
						onClick: () => setShowConfirmation(false),
						className: 'button',
						style: {
						  backgroundColor: '#e74c3c',
						  padding: '12px 30px',
						  fontSize: '1.1em',
						  transition: 'all 0.3s ease'
						}
					  }, 'Cancel')
					])
				  ])
				);

				return React.createElement('div', { className: 'main-menu' }, [
				  React.createElement('div', {
					key: 'header',
					style: {
					  position: 'absolute',
					  top: '20px',
					  right: '20px',
					  backgroundColor: '#2a2a2a',
					  padding: '15px',
					  borderRadius: '8px',
					  zIndex: 3
					}
				  }, [
					React.createElement('p', {
					  key: 'points',
					  style: {
						color: '#4CAF50',
						fontSize: '1.2em',
						margin: 0
					  }
					}, `Available Skill Points: ${skillPoints}`),
					React.createElement('button', {
					  key: 'center',
					  onClick: resetPosition,
					  style: {
						backgroundColor: '#1a1a1a',
						padding: '8px 15px',
						borderRadius: '4px',
						cursor: 'pointer',
						border: '1px solid #4CAF50',
						color: '#4CAF50',
						transition: 'all 0.2s ease'
					  },
					  onMouseOver: (e) => {
						e.target.style.backgroundColor = '#2f2f2f';
					  },
					  onMouseOut: (e) => {
						e.target.style.backgroundColor = '#1a1a1a';
					  }
					}, 'Center View')
				  ]),
				  React.createElement('div', {
					key: 'title',
					className: 'game-title'
				  }, 'Talents'),
				  React.createElement('div', {
					key: 'map-container',
					style: {
					  width: '100%',
					  height: '500px',
					  overflow: 'hidden',
					  position: 'relative',
					  backgroundColor: '#1a1a1a',
					  border: '2px solid #333',
					  borderRadius: '8px'
					}
				  }, React.createElement('div', {
					onMouseDown: (e) => !e.target.classList.contains('node') && handleMouseDown(e),
					onMouseMove: handleMouseMove,
					onMouseUp: handleMouseUp,
					onMouseLeave: handleMouseUp,
					style: {
					  position: 'absolute',
					  width: '2000px',
					  height: '1500px',
					  transform: `translate(${mapPosition.x}px, ${mapPosition.y}px)`,
					  cursor: isDragging ? 'grabbing' : 'grab'
					}
				  }, [
					React.createElement('svg', {
					  key: 'paths',
					  width: '100%',
					  height: '100%',
					  style: {
						position: 'absolute',
						top: 0,
						left: 0,
						pointerEvents: 'none'
					  }
					}, cardDrawPath.map((node, index) => {
					  if (index === 0) {
						return React.createElement('line', {
						  key: `line-${node.id}`,
						  x1: centerX,
						  y1: centerY,
						  x2: node.x,
						  y2: node.y,
						  stroke: unlockedNodes.includes(node.id) ? '#4CAF50' : '#666',
						  strokeWidth: 2
						});
					  }
					  const prevNode = cardDrawPath[index - 1];
					  return React.createElement('line', {
						key: `line-${node.id}`,
						x1: prevNode.x,
						y1: prevNode.y,
						x2: node.x,
						y2: node.y,
						stroke: unlockedNodes.includes(node.id) ? '#4CAF50' : '#666',
						strokeWidth: 2
					  });
					})),
					...cardDrawPath.map(node => 
					  React.createElement('div', {
						key: node.id,
						className: 'node',
						onClick: (e) => node.isIdentifier ? null : handleNodeClick(e, node),
						style: {
						  position: 'absolute',
						  left: node.x - 20,
						  top: node.y - 20,
						  width: 40,
						  height: 40,
						  borderRadius: '50%',
						  backgroundColor: node.isIdentifier ? '#e74c3c' : // Special color for identifier
							unlockedNodes.includes(node.id) ? '#4CAF50' : '#444',
						  border: '2px solid ' + (
							node.isIdentifier ? '#e74c3c' : // Special border for identifier
							unlockedNodes.includes(node.id) ? '#4CAF50' : '#666'
						  ),
						  cursor: node.isIdentifier ? 'default' : // No pointer for identifier
							(node.id === 'cardDraw1' || unlockedNodes.includes(`cardDraw${parseInt(node.id.replace('cardDraw', '')) - 1}`)) 
							? 'pointer' : 'not-allowed',
						  opacity: node.isIdentifier ? 1 : // Always full opacity for identifier
							(node.id === 'cardDraw1' || unlockedNodes.includes(`cardDraw${parseInt(node.id.replace('cardDraw', '')) - 1}`))
							? 1 : 0.5,
						  transition: 'all 0.3s ease',
						  zIndex: 2,
						}
					  })
					)
				  ])),
				  React.createElement('div', {
					  style: {
						position: 'absolute',
						width: '2000px',
						height: '1500px',
						transform: `translate(${mapPosition.x}px, ${mapPosition.y}px)`,
						pointerEvents: 'none'
					  }
					}, 
					  React.createElement('div', {
						style: {
						  position: 'absolute',
						  left: `${cardDrawPath[0].x - 40}px`,
						  top: `${cardDrawPath[0].y + 30}px`,
						  width: 80,
						  textAlign: 'center',
						  color: '#e74c3c',
						  fontWeight: 'bold',
						  fontSize: '14px',
						  zIndex: 3
						}
					  }, 'Card Draw')
					),
				  React.createElement('button', {
					key: 'back-button',
					onClick: handleBackToMenu,
					style: {
					  fontFamily: 'Cinzel, serif',
					  fontSize: '1.5rem',
					  color: '#fff',
					  backgroundColor: '#e74c3c',
					  border: 'none',
					  padding: '1rem 3rem',
					  borderRadius: '8px',
					  cursor: 'pointer',
					  marginTop: '2rem'
					}
				  }, 'Back'),
				  showConfirmation && React.createElement(NodePopup)
				]);
			  };

            // Initialize game
            const shuffleArray = (array) => {
                const newArray = [...array];
                for (let i = newArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
                }
                return newArray;
            };

            const initializeGame = () => {
				initializeUnlockedCards();
				// Define initial deck composition
				const initialDeckTypes = [
					'multiAttack', 'multiAttack',  // 2 multi-attacks
					'singleAttack', 'singleAttack', 'singleAttack', 'singleAttack',  // 4 single attacks
					'empower',  // 1 empower
					'counter'   // 1 counter
				];
				
				// Create card instances with unique IDs
				const initialDeck = initialDeckTypes.map((type, index) => ({
					id: index + 1,
					type: type
				}));
				
				// Update ID counter to be after the last card created
				setCardIdCounter(initialDeck.length);
				
				// Shuffle and split into initial hand and deck
				const shuffledCards = shuffleArray([...initialDeck]);
				const initialHand = shuffledCards.slice(0, 3);
				const remainingDeck = shuffledCards.slice(3);
				
				// Initial enemies setup
				const initialEnemyCount = Math.floor(Math.random() * 2) + 1; // 1 or 2 enemies
				const initialEnemies = Array(initialEnemyCount).fill().map(() => ({
					health: 20,
					maxHealth: 20,
					intent: 'attack',
					damage: 5,
					damageNumbers: []
				}));
				
				// Set all initial states at once to prevent race conditions
				setRound(1);
				setDeck(remainingDeck);
				setHand(initialHand);
				setDiscardPile([]);
				setExhaustedCards([]);
				setEnemies(initialEnemies);
				setGameStarted(true);
				setTotalDeckSize(initialDeck.length);
				setPlayerHealth(100);
				setPlayerEnergy(3);
				setEmpowerActive(false);
				setCounterActive(false);
				setShowVictory(false);
			};

            // Initialize game on mount
			useEffect(() => {
				initializeGame();
			}, []);

			useEffect(() => {
				if (enemies.length === 0 && !showVictory && gameStarted && round > 0 && enemies !== undefined) {
					// Only handle victory if we've actually defeated enemies, not during initialization
					handleVictory();
				}
			}, [enemies, gameStarted, round]);

			// Debug logging
			useEffect(() => {
				if (gameStarted) {
					logCardCounts();
				}
			}, [deck, hand, discardPile]);
			
			useEffect(() => {
				if (gameStarted) {
					spawnEnemies();
				}
			}, [gameStarted]);
			
			useEffect(() => {
				const startGame = () => {
					if (showMainMenu) {
						setShowMainMenu(false);
						handleSplashToMenu(); // Changed from setGameStarted(true)
					}
				};

				const handleKeyPress = () => startGame();
				const handleClick = () => startGame();
				
				window.addEventListener('keydown', handleKeyPress);
				window.addEventListener('click', handleClick);
				
				return () => {
					window.removeEventListener('keydown', handleKeyPress);
					window.removeEventListener('click', handleClick);
				};
			}, [showMainMenu]);

		// Create MainMenu component
		const MainMenu = ({ onStartRun, onTalents }) => {
		  return React.createElement('div', { 
			className: 'main-menu'
		  },
			React.createElement('div', {
			  className: 'game-title',
			  style: { marginBottom: '4rem' }
			}, 'RAID BOSS'),
			React.createElement('div', {
			  style: {
				display: 'flex',
				flexDirection: 'column',
				gap: '2rem',
				alignItems: 'center'
			  }
			},
			  React.createElement('button', {
				onClick: onStartRun,
				style: {
				  fontFamily: 'Cinzel, serif',
				  fontSize: '2rem',
				  color: '#fff',
				  backgroundColor: '#e74c3c',
				  border: 'none',
				  padding: '1rem 3rem',
				  borderRadius: '8px',
				  cursor: 'pointer',
				  transition: 'all 0.3s ease',
				  textShadow: '0 0 10px rgba(231, 76, 60, 0.5)',
				  boxShadow: '0 0 15px rgba(231, 76, 60, 0.3)',
				},
				onMouseOver: (e) => {
				  e.target.style.transform = 'scale(1.05)';
				  e.target.style.boxShadow = '0 0 25px rgba(231, 76, 60, 0.5)';
				},
				onMouseOut: (e) => {
				  e.target.style.transform = 'scale(1)';
				  e.target.style.boxShadow = '0 0 15px rgba(231, 76, 60, 0.3)';
				}
			  }, 'Start Run'),
			  
			  React.createElement('button', {
				onClick: onTalents,
				style: {
				  fontFamily: 'Cinzel, serif',
				  fontSize: '2rem',
				  color: '#fff',
				  backgroundColor: '#e74c3c',
				  border: 'none',
				  padding: '1rem 3rem',
				  borderRadius: '8px',
				  cursor: 'pointer',
				  transition: 'all 0.3s ease',
				  textShadow: '0 0 10px rgba(231, 76, 60, 0.5)',
				  boxShadow: '0 0 15px rgba(231, 76, 60, 0.3)',
				},
				onMouseOver: (e) => {
				  e.target.style.transform = 'scale(1.05)';
				  e.target.style.boxShadow = '0 0 25px rgba(231, 76, 60, 0.5)';
				},
				onMouseOut: (e) => {
				  e.target.style.transform = 'scale(1)';
				  e.target.style.boxShadow = '0 0 15px rgba(231, 76, 60, 0.3)';
				}
			  }, 'Talents'),

			  // Add clear save button
			  React.createElement('button', {
				onClick: clearSaveData,
				style: {
				  padding: '10px',
				  marginTop: '20px'
				}
			  }, 'Clear Save Data')
			)
		  );
		};

		
		const handleSpecialReward = (cardType) => {
			const newCard = {
				id: cardIdCounter + 1,
				type: cardType
			};
			setCardIdCounter(prev => prev + 1);
			
			// Add card to deck instead of hand
			setDeck(prev => [...prev, newCard]);
			setTotalDeckSize(prev => prev + 1);

			const remainingPicks = specialRewardOptions.length === 5 ? 1 : 0;
			
			if (remainingPicks === 0) {
				setShowSpecialRewards(false);
				// Don't show victory screen after special rewards
				spawnEnemies();
				drawCards(); // Draw a fresh hand of exactly 3 cards
			} else {
				setSpecialRewardOptions(prev => prev.filter(card => card !== cardType));
			}
		};
		
		const SpecialRewardsOverlay = ({ rewards, onSelectReward, remainingPicks }) => {
			return React.createElement('div', { className: 'victory-overlay' },
				React.createElement('div', { className: 'victory-content' },
					React.createElement('h2', {
						style: { 
							fontFamily: 'Cinzel, serif',
							fontSize: '2.5rem',
							color: '#e74c3c',
							marginBottom: '2rem'
						}
					}, 'Choose Your Rewards'),
					React.createElement('p', {
						style: {
							fontSize: '1.5rem',
							color: '#fff',
							marginBottom: '2rem'
						}
					}, `Select ${remainingPicks} more card${remainingPicks !== 1 ? 's' : ''}`),
					React.createElement('div', { 
						className: 'rewards-container',
						style: {
							display: 'grid',
							gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
							gap: '20px',
							padding: '20px'
						}
					},
						rewards.map((cardType, index) => {
							const card = cardTypes[cardType];
							return React.createElement('div', {
								key: index,
								className: 'reward-card',
								onClick: () => onSelectReward(cardType),
								style: {
									backgroundColor: '#444',
									padding: '15px',
									borderRadius: '8px',
									cursor: 'pointer',
									transition: 'all 0.2s',
									border: '2px solid transparent',
									'&:hover': {
										transform: 'translateY(-5px)',
										borderColor: '#4CAF50',
										boxShadow: '0 0 15px rgba(76, 175, 80, 0.5)'
									}
								}
							},
								React.createElement('h3', null, card.name),
								React.createElement('p', null, `Cost: ${card.cost} Energy`),
								React.createElement('p', null, card.description)
							);
						})
					)
				)
			);
		};
		
		const handleSplashToMenu = () => {
        setCurrentScreen('menu');
		};

		const handleStartRun = () => {
			setCurrentScreen('game');
			initializeGame();
		};

		const handleTalents = () => {
			setCurrentScreen('talents');
		};

		const handleBackToMenu = () => {
			setCurrentScreen('menu');
		};
		
				
		const updateBossIntents = (boss) => {
			// Phase transition check
			if (boss.health <= boss.maxHealth * 0.5 && boss.phase === 1) {
				boss.phase = 2;
				setStatusMessage('The boss becomes enraged!');
				setShowStatusMessage(true);
				setTimeout(() => setShowStatusMessage(false), 2000);
				
				return {
					...boss,
					damage: boss.damage + 5,
					phase: 2,
					intents: [{
						type: 'attack',
						description: `Preparing to attack for ${boss.damage + 5} damage`
					}]
				};
			}

			if (boss.phase === 2) {
				// Get available actions excluding the last one used
				const availableActions = getAvailableBossActions(bossLastAction);
				const randomAction = availableActions[Math.floor(Math.random() * availableActions.length)];
				
				let newBoss = { ...boss };
				
				switch (randomAction) {
					case 'attack':
						setBossLastAction('attack');
						newBoss.intents = [{
							type: 'attack',
							description: `Preparing to attack for ${boss.damage} damage`
						}];
						break;
						
					case 'spawn':
						setBossLastAction('spawn');
						newBoss.intents = [{
							type: 'spawn',
							description: 'Summoning reinforcements...'
						}];
						break;
						
					case 'weaken':
						setBossLastAction('weaken');
						newBoss.intents = [{
							type: 'weaken',
							description: 'Preparing to weaken you...'
						}];
						break;
				}
				
				return newBoss;
			}

			// Phase 1 behavior
			if (boss.turnsUntilSpawn <= 0) {
				return {
					...boss,
					turnsUntilSpawn: 2,
					intents: [{
						type: 'spawn',
						description: 'Summoning minions...'
					}]
				};
			} else {
				return {
					...boss,
					turnsUntilSpawn: boss.turnsUntilSpawn - 1,
					intents: [{
						type: 'attack',
						description: `Preparing to attack for ${boss.damage} damage`
					}]
				};
			}
		};
		
		const PreBossFight = ({ currentHealth, maxHealth }) => {
			const isFullHealth = currentHealth === maxHealth;
			const actualHealAmount = Math.min(50, maxHealth - currentHealth);

			// Define button styles
			const ButtonStyle = {
				fontFamily: 'Cinzel, serif',
				fontSize: '1.5rem',
				color: '#fff',
				backgroundColor: '#e74c3c',
				border: 'none',
				padding: '1.5rem',
				borderRadius: '8px',
				cursor: 'pointer',
				transition: 'all 0.3s ease',
				textShadow: '0 0 10px rgba(231, 76, 60, 0.5)',
				boxShadow: '0 0 15px rgba(231, 76, 60, 0.3)',
				width: '100%',
				display: 'flex',
				flexDirection: 'column',
				alignItems: 'center',
				justifyContent: 'center',
				minHeight: '120px'
			};

			const ButtonHoverHandlers = {
				onMouseOver: (e) => {
					e.target.style.transform = 'scale(1.05)';
					e.target.style.boxShadow = '0 0 25px rgba(231, 76, 60, 0.5)';
				},
				onMouseOut: (e) => {
					e.target.style.transform = 'scale(1)';
					e.target.style.boxShadow = '0 0 15px rgba(231, 76, 60, 0.3)';
				}
			};

			const handlePreBossAction = (action) => {
				// Execute the chosen action
				action();
				
				// Progress to round 15
				setRound(15);
				setPlayerEnergy(3);
				setEmpowerActive(false);
				setCounterActive(false);
				setShowPreBossFight(false);
				
				// Spawn boss enemies
				spawnEnemies();
				
				// Draw new hand
				setTimeout(() => {
					const newHand = deck.slice(0, 3);
					const remainingDeck = deck.slice(3);
					setHand(newHand);
					setDeck(remainingDeck);
				}, 0);
			};

			return React.createElement('div', { className: 'victory-overlay' },
				React.createElement('div', { 
					className: 'victory-content',
					style: {
						backgroundColor: '#2a2a2a',
						padding: '40px',
						borderRadius: '8px',
						textAlign: 'center',
						maxWidth: '900px',
						width: '90%'
					}
				},
					React.createElement('h2', {
						style: {
							fontFamily: 'Cinzel, serif',
							fontSize: '3rem',
							color: '#e74c3c',
							marginBottom: '2rem',
							textShadow: '0 0 10px rgba(231, 76, 60, 0.5)'
						}
					}, 'Boss Battle Approaching!'),
					React.createElement('p', {
						style: {
							fontSize: '1.5rem',
							color: '#fff',
							marginBottom: '2rem'
						}
					}, 'Choose one bonus before facing the boss:'),
					React.createElement('div', {
						style: {
							display: 'grid',
							gridTemplateColumns: '1fr 1fr',
							gap: '20px',
							padding: '20px'
						}
					},
						// Heal Button
						React.createElement('button', {
							style: {
								...ButtonStyle,
								opacity: isFullHealth ? 0.6 : 1,
								cursor: isFullHealth ? 'not-allowed' : 'pointer',
								backgroundColor: isFullHealth ? '#666' : '#e74c3c'
							},
							onClick: isFullHealth ? null : () => handlePreBossAction(() => {
								setPlayerHealth(prev => Math.min(maxHealth, prev + 50));
							}),
							disabled: isFullHealth,
							...ButtonHoverHandlers
						},
							React.createElement('div', null, 'Heal'),
							React.createElement('div', {
								style: { fontSize: '1.2rem', marginTop: '0.5rem', opacity: 0.9 }
							}, isFullHealth ? 'Already at full health' : 
							   actualHealAmount < 50 ? `Restore ${actualHealAmount} HP` : 'Restore 50 HP'),
							React.createElement('div', {
								style: { fontSize: '1rem', marginTop: '0.5rem', opacity: 0.8 }
							}, `Current HP: ${currentHealth}/${maxHealth}`)
						),
						
						// Max HP Button
						React.createElement('button', {
							style: ButtonStyle,
							onClick: () => handlePreBossAction(() => {
								setMaxHealth(prev => prev + 25);
								setPlayerHealth(prev => prev + 25);
							}),
							...ButtonHoverHandlers
						},
							React.createElement('div', null, 'Increase Max HP'),
							React.createElement('div', {
								style: { fontSize: '1.2rem', marginTop: '0.5rem', opacity: 0.9 }
							}, '+25 Maximum HP'),
							React.createElement('div', {
								style: { fontSize: '1rem', marginTop: '0.5rem', opacity: 0.8 }
							}, `New Max HP will be: ${maxHealth + 25}`)
						),
						
						// Double Rewards Button
						React.createElement('button', {
							style: ButtonStyle,
							onClick: () => handlePreBossAction(() => {
								onDoubleRewards();
							}),
							...ButtonHoverHandlers
						},
							React.createElement('div', null, 'Double Rewards'),
							React.createElement('div', {
								style: { fontSize: '1.2rem', marginTop: '0.5rem', opacity: 0.9 }
							}, 'Choose 2 cards from 5')
						),
						
						// Remove Card Button
						React.createElement('button', {
							style: ButtonStyle,
							onClick: () => handlePreBossAction(() => {
								setShowCardRemoval(true);
							}),
							...ButtonHoverHandlers
						},
							React.createElement('div', null, 'Remove Card'),
							React.createElement('div', {
								style: { fontSize: '1.2rem', marginTop: '0.5rem', opacity: 0.9 }
							}, 'Remove a card from your deck')
						)
					)
				)
			);
		};

		
				const spawnEnemies = () => {
					// Skip spawning if we're still in initialization
					if (!gameStarted) return;
					
					// Boss fight at round 15
					if (round === 15) {
						setEnemies([{
							...bossEnemy,
							intents: [{
								type: 'spawn',
								description: 'Summoning reinforcements...'
							}]
						}]);
						return;
					}
					
					// Regular enemy spawning logic
					let minEnemies = 1;
					let maxEnemies;
					
					if (round <= 5) {
						maxEnemies = 2;
					} else if (round <= 10) {
						maxEnemies = 3;
					} else {
						maxEnemies = 4;
					}
					
					const numberOfEnemies = minEnemies + Math.floor(Math.random() * (maxEnemies - minEnemies + 1));
					
					const newEnemies = Array(numberOfEnemies).fill().map(() => ({
						health: 20,
						maxHealth: 20,
						intent: 'attack',
						damage: 5,
						damageNumbers: []
					}));
					
					setEnemies(newEnemies);
				};
		
			const createDamageNumber = (amount, id) => ({
				amount,
				id,
				createdAt: Date.now()
			});


            const drawCards = () => {
				let currentDeck = [...deck];
				let currentDiscard = [...discardPile];
				let cardsNeeded = 3;

				// If we need to shuffle discard into deck
				if (currentDeck.length < cardsNeeded && currentDiscard.length > 0) {
					// Add all cards together and shuffle
					currentDeck = shuffleArray([...currentDeck, ...currentDiscard]);
					currentDiscard = [];
				}

				// Draw up to 3 cards
				const newHand = currentDeck.slice(0, cardsNeeded);
				const remainingDeck = currentDeck.slice(cardsNeeded);

				// Log before setting state
				console.log('Draw Cards:', {
					preTotal: deck.length + discardPile.length + hand.length,
					newHand: newHand.length,
					remainingDeck: remainingDeck.length,
					discard: currentDiscard.length,
					postTotal: newHand.length + remainingDeck.length + currentDiscard.length
				});

				// Update all states
				setDeck(remainingDeck);
				setHand(newHand);
				setDiscardPile(currentDiscard);
			};

            const selectCard = (card, index) => {
				const cardDef = cardTypes[card.type];
				const discountType = discountedCards.get(card.id);
				
				// Calculate cost consistently
				let currentCost = cardDef.cost;
				if (discountType === "zero") {
					currentCost = 0;
				} else if (discountType === "reduced") {
					currentCost = Math.max(0, cardDef.cost - 1);
				}
				
				if (playerEnergy >= currentCost) {
					console.log('Card Selected:', {
						type: card.type,
						id: card.id,
						baseCost: cardDef.cost,
						discountType,
						finalCost: currentCost,
						needsTarget: cardDef.needsTarget,
						energy: playerEnergy
					});
					
					if (cardDef.needsTarget) {
						setSelectedCard(card);
						setSelectedCardIndex(index);
						setIsTargeting(true);
					} else {
						playCard(card, index);
					}
				}
			};

            const selectTarget = (targetIndex) => {
				if (isTargeting && selectedCard) {
					// Store the card and index before resetting states
					const card = selectedCard;
					const index = selectedCardIndex;
					
					// Reset targeting state
					setIsTargeting(false);
					setSelectedCard(null);
					setSelectedCardIndex(null);
					
					// Play the card
					playCard(card, index, targetIndex);
					
					console.log('Target Selected:', {
						cardType: card.type,
						cardId: card.id,
						targetIndex,
						enemyHealth: enemies[targetIndex].health
					});
				}
			};

            const playCard = (card, handIndex, targetIndex = null) => {
				if (gameOver) return;

				const cardDef = cardTypes[card.type];
				const discountType = discountedCards.get(card.id);
				
				// Use the same cost calculation logic as selectCard
				let currentCost = cardDef.cost;
				if (discountType === "zero") {
					currentCost = 0;
				} else if (discountType === "reduced") {
					currentCost = Math.max(0, cardDef.cost - 1);
				}

				console.log('Playing card:', {
					type: card.type,
					id: card.id,
					baseCost: cardDef.cost,
					discountType,
					finalCost: currentCost,
					targetIndex,
					energy: playerEnergy
				});

				if (playerEnergy >= currentCost) {
					// Deduct energy using the calculated cost
					setPlayerEnergy(prev => prev - currentCost);
					
					// Remove the discount from the played card
					setDiscountedCards(prev => {
						const newDiscounts = new Map(prev);
						newDiscounts.delete(card.id);
						return newDiscounts;
					});

					if (card.type === 'freshStart') {
						cardDef.effect(enemies, handIndex);
					} else {
						const newHand = [...hand];
						const playedCard = newHand.splice(handIndex, 1)[0];
						setHand(newHand);

						const updatedEnemies = cardDef.effect(enemies, targetIndex);
						setEnemies(updatedEnemies.filter(enemy => enemy.health > 0));

						if (cardDef.exhausts) {
							setExhaustedCards(prev => [...prev, playedCard]);
						} else {
							setDiscardPile(prev => [...prev, playedCard]);
						}

						const attackCards = ['singleAttack', 'multiAttack', 'quickStrike', 'heavyAttack', 'doubleHit', 'healthSiphon'];
						if (attackCards.includes(card.type)) {
							setEmpowerActive(false);
						}
					}

					// Always clear targeting state after playing a card
					setIsTargeting(false);
					setSelectedCard(null);
					setSelectedCardIndex(null);
				}
			};
			
			// Add this helper function to calculate card cost consistently
			const calculateCardCost = (card) => {
				const cardDef = cardTypes[card.type];
				const discountType = discountedCards.get(card.id);
				
				if (discountType === "zero") return 0;
				if (discountType === "reduced") return Math.max(0, cardDef.cost - 1);
				return cardDef.cost;
			};
			
			const getUniqueCards = (cards) => {
				const seen = new Set();
				return cards.filter(card => {
					const key = `${card.type}${card.id}`;
					if (seen.has(key)) return false;
					seen.add(key);
					return true;
				});
			};
						
			

            
				const endTurn = () => {
					if (gameOver) return;

					// Clear weakened status at end of player turn
					setPlayerWeakened(false);
					
					// Store current card states before processing
					const currentHand = [...hand];
					const currentDeck = [...deck];
					const currentDiscard = [...discardPile];
					
					// Process enemy actions
					let updatedEnemies = [...enemies];
						let counterUsed = false;

						updatedEnemies = updatedEnemies.map(enemy => {
							if (enemy.isBoss) {
								const updatedBoss = updateBossIntents(enemy);
								const currentIntent = updatedBoss.intents[0];
								
								switch (currentIntent.type) {
									case 'attack':
										if (counterActive && !counterUsed) {
											counterUsed = true;
											updatedBoss.health -= updatedBoss.damage;
											updatedBoss.damageNumbers = [
												...updatedBoss.damageNumbers,
												createDamageNumber(updatedBoss.damage, Date.now())
											];
										} else if (!counterActive) {
											const newHealth = playerHealth - updatedBoss.damage;
											setPlayerHealth(newHealth);
											if (newHealth <= 0) setGameOver(true);
										}
										break;

									case 'spawn':
										if (updatedEnemies.length < 4) {
											const minionsToSpawn = updatedBoss.phase === 1 ? 1 : 2;
											const newMinions = Array(minionsToSpawn).fill().map(() => ({
												health: 12,
												maxHealth: 12,
												intent: 'attack',
												damage: 4,
												damageNumbers: [],
												isMinion: true
											}));
											updatedEnemies = [updatedBoss, ...newMinions];
										}
										break;

									case 'weaken':
										setPlayerWeakened(true);
										setStatusMessage('You have been weakened! -1 damage this turn');
										setShowStatusMessage(true);
										setTimeout(() => setShowStatusMessage(false), 2000);
										break;
								}
								
								return updatedBoss;
							} else {
								if (enemy.intent === 'attack') {
									if (counterActive && !counterUsed) {
										counterUsed = true;
										return {
											...enemy,
											health: Math.max(0, enemy.health - enemy.damage),
											damageNumbers: [
												...enemy.damageNumbers,
												createDamageNumber(enemy.damage, Date.now())
											]
										};
									} else if (!counterActive) {
										const newHealth = playerHealth - enemy.damage;
										setPlayerHealth(newHealth);
										if (newHealth <= 0) setGameOver(true);
									}
								}
								return enemy;
							}
						}).filter(enemy => enemy.health > 0);

						setEnemies(updatedEnemies);
    
					// Clear current hand to discard pile
					const newDiscard = [...currentDiscard, ...currentHand];
					
					// If deck has enough cards, draw from it
					if (currentDeck.length >= 3) {
						const newHand = currentDeck.slice(0, 3);
						const remainingDeck = currentDeck.slice(3);
						setHand(newHand);
						setDeck(remainingDeck);
						setDiscardPile(newDiscard);
					} else {
						// If deck doesn't have enough cards, shuffle in the discard pile
						const allCards = [...currentDeck, ...newDiscard];
						const shuffledCards = shuffleArray(allCards);
						const newHand = shuffledCards.slice(0, 3);
						const remainingDeck = shuffledCards.slice(3);
						setHand(newHand);
						setDeck(remainingDeck);
						setDiscardPile([]);
					}
					
					// Reset states
					setCounterActive(false);
					setPlayerEnergy(3);
					setIsTargeting(false);
					setSelectedCard(null);
					setSelectedCardIndex(null);
					setDiscountedCards(new Map());
				};
			

			
			const validateCardCount = () => {
				const current = deck.length + hand.length + discardPile.length + exhaustedCards.length;
				console.log('Card Count Validation:', {
					expected: totalDeckSize,
					current,
					difference: totalDeckSize - current,
					deck: deck.length,
					hand: hand.length,
					discard: discardPile.length,
					exhausted: exhaustedCards.length
				});
				return current === totalDeckSize;
			};
			
			// Add a card tracking function
			const trackCardMovement = (source, destination, cards) => {
				console.log('Card Movement:', {
					from: source,
					to: destination,
					cards: cards,
					totalBefore: deck.length + hand.length + discardPile.length + exhaustedCards.length,
					deckSize: deck.length,
					handSize: hand.length,
					discardSize: discardPile.length,
					exhaustedSize: exhaustedCards.length
				});
			};
			
			const trackCards = (action) => {
				const total = deck.length + hand.length + discardPile.length + exhaustedCards.length;
				console.log('Card Count:', {
					action,
					total,
					deck: deck.length,
					hand: hand.length,
					discard: discardPile.length,
					exhausted: exhaustedCards.length,
					deckCards: [...deck],
					handCards: [...hand],
					discardCards: [...discardPile],
					exhaustedCards: [...exhaustedCards]
				});
			};
			
			const handleCardRemoval = (cardToRemove) => {
				// Remove card from appropriate pile
				setDeck(prev => prev.filter(card => card.id !== cardToRemove.id));
				setHand(prev => prev.filter(card => card.id !== cardToRemove.id));
				setDiscardPile(prev => prev.filter(card => card.id !== cardToRemove.id));
				
				// Update total deck size
				setTotalDeckSize(prev => prev - 1);
				
				// Hide removal screen and proceed to boss fight
				setShowCardRemoval(false);
				setShowVictory(true);
				setEmpowerActive(false);
				
				// Set up boss fight rewards
				const possibleRewards = Object.keys(cardTypes);
				const rewards = [];
				while (rewards.length < 3) {
					const randomCard = possibleRewards[Math.floor(Math.random() * possibleRewards.length)];
					if (!rewards.includes(randomCard)) {
						rewards.push(randomCard);
					}
				}
				setRewardOptions(rewards);
			};
			
			const onDoubleRewards = () => {
				// Generate 5 random unique cards
				const possibleRewards = Object.keys(cardTypes);
				const specialRewards = [];
				while (specialRewards.length < 5) {
					const randomCard = possibleRewards[Math.floor(Math.random() * possibleRewards.length)];
					if (!specialRewards.includes(randomCard)) {
						specialRewards.push(randomCard);
					}
				}
				setSpecialRewardOptions(specialRewards);
				setShowSpecialRewards(true);
				setShowPreBossFight(false);
			};

			const drawNewHand = (currentDiscard) => {
				let currentDeck = [...deck];
				
				// If we don't have enough cards in deck, shuffle in the discard pile
				if (currentDeck.length < 3 && currentDiscard.length > 0) {
					currentDeck = shuffleArray([...currentDeck, ...currentDiscard]);
					setDiscardPile([]);
				}
				
				// Draw up to 3 cards
				const newHand = currentDeck.slice(0, 3);
				const remainingDeck = currentDeck.slice(3);
				
				// Log before setting new state
				console.log('Drawing New Hand:', {
					newHand: newHand,
					remainingDeck: remainingDeck,
					total: newHand.length + remainingDeck.length
				});

				// Update states
				setDeck(remainingDeck);
				setHand(newHand);
			};

            const canEndTurn = !isTargeting && (
				playerEnergy === 0 || 
				hand.every(card => cardTypes[card.type].cost > playerEnergy)
			);
			
			const clearSaveData = () => {
			  localStorage.removeItem('knowledgePoints');
			  localStorage.removeItem('skillPoints');
			  localStorage.removeItem('unlockedNodes');
			  setKnowledgePoints(0);
			  setSkillPoints(0);
			  setUnlockedNodes([]);
			};
			
			const handleVictory = () => {
				const pointsGained = round === 15 ? 100 : 10;
				let newKnowledgePoints = knowledgePoints + pointsGained;
				let additionalSkillPoints = Math.floor(newKnowledgePoints / 100);
				
				// Convert excess knowledge points to skill points
				if (additionalSkillPoints > 0) {
					newKnowledgePoints = newKnowledgePoints % 100;
					setSkillPoints(prev => {
						const newTotal = prev + additionalSkillPoints;
						localStorage.setItem('skillPoints', newTotal.toString());
						return newTotal;
					});
				}
				
				setKnowledgePoints(newKnowledgePoints);
				localStorage.setItem('knowledgePoints', newKnowledgePoints.toString());

				// Show points gained message
				let message = `+${pointsGained} Knowledge Points!`;
				if (additionalSkillPoints > 0) {
					message += ` +${additionalSkillPoints} Skill Points!`;
				}
				setStatusMessage(message);
				setShowStatusMessage(true);
				setTimeout(() => setShowStatusMessage(false), 2000);

				// Handle rewards and victory state
				if (round === 14) {
					// Set up pre-boss rewards
					const possibleRewards = Object.keys(cardTypes);
					const rewards = [];
					while (rewards.length < 3) {
						const randomCard = possibleRewards[Math.floor(Math.random() * possibleRewards.length)];
						if (!rewards.includes(randomCard)) {
							rewards.push(randomCard);
						}
					}
					setRewardOptions(rewards);
					setShowVictory(true);
					setEmpowerActive(false);
				} else {
					// Normal victory handling
					const possibleRewards = Object.keys(cardTypes);
					const rewards = [];
					while (rewards.length < 3) {
						const randomCard = possibleRewards[Math.floor(Math.random() * possibleRewards.length)];
						if (!rewards.includes(randomCard)) {
							rewards.push(randomCard);
						}
					}
					setRewardOptions(rewards);
					setShowVictory(true);
					setEmpowerActive(false);
				}
			};

			const selectReward = (cardType) => {
				console.log('Selecting reward for round:', round);
				
				// Create new card with unique ID
				const newCard = {
					id: cardIdCounter + 1,
					type: cardType
				};
				setCardIdCounter(prev => prev + 1);
				
				// Get current cards and add new one
				const currentCards = [...deck, ...discardPile, ...hand, ...exhaustedCards];
				const allCards = [...currentCards, newCard];
				const shuffledDeck = shuffleArray(allCards);
				
				// Reset basic game state
				setDeck(shuffledDeck);
				setHand([]);
				setDiscardPile([]);
				setExhaustedCards([]);
				setDiscountedCards(new Map());
				setTotalDeckSize(prev => prev + 1);
				setShowVictory(false);
				setPlayerEnergy(3);
				setEmpowerActive(false);
				setCounterActive(false);

				if (round === 14) {
					// After round 14 reward, show pre-boss screen
					setShowPreBossFight(true);
				} else {
					// Normal round progression
					setRound(prev => prev + 1);
					spawnEnemies();
					
					// Draw new hand
					setTimeout(() => {
						const newHand = shuffledDeck.slice(0, 3);
						const remainingDeck = shuffledDeck.slice(3);
						setHand(newHand);
						setDeck(remainingDeck);
					}, 0);
				}
			};
			
			const handlePreBossAction = (action) => {
				// Execute the chosen action
				action();
				
				// Progress to round 15
				setRound(15);
				setPlayerEnergy(3);
				setEmpowerActive(false);
				setCounterActive(false);
				setShowPreBossFight(false);
				
				// Spawn boss enemies and draw new hand
				spawnEnemies();
				
				setTimeout(() => {
					const newHand = deck.slice(0, 3);
					const remainingDeck = deck.slice(3);
					setHand(newHand);
					setDeck(remainingDeck);
				}, 0);
			};
			
			const logCardCounts = () => {
				console.log('Card Counts:', {
					total: deck.length + hand.length + discardPile.length + exhaustedCards.length,
					deck: deck.length,
					hand: hand.length,
					discard: discardPile.length,
					exhausted: exhaustedCards.length,
					deckCards: deck,
					handCards: hand,
					discardCards: discardPile,
					exhaustedCards: exhaustedCards
				});
			};
			
			const CardRemovalOverlay = ({ deck, hand, discardPile, onRemoveCard }) => {
				// Combine all cards into one array for display
				const allCards = [...deck, ...hand, ...discardPile].sort((a, b) => {
					const cardA = cardTypes[a.type];
					const cardB = cardTypes[b.type];
					return cardA.name.localeCompare(cardB.name);
				});

				return React.createElement('div', { className: 'victory-overlay' },
					React.createElement('div', { 
						className: 'victory-content',
						style: {
							backgroundColor: '#2a2a2a',
							padding: '40px',
							borderRadius: '8px',
							textAlign: 'center',
							maxWidth: '1000px',
							width: '95%'
						}
					},
						React.createElement('h2', {
							style: {
								fontFamily: 'Cinzel, serif',
								fontSize: '2.5rem',
								color: '#e74c3c',
								marginBottom: '2rem'
							}
						}, 'Remove a Card'),
						React.createElement('p', {
							style: {
								fontSize: '1.5rem',
								color: '#fff',
								marginBottom: '2rem'
							}
						}, 'Select a card to remove from your deck:'),
						React.createElement('div', {
							style: {
								display: 'grid',
								gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
								gap: '15px',
								maxHeight: '60vh',
								overflowY: 'auto',
								padding: '10px'
							}
						},
							allCards.map((card, index) => {
								const cardType = cardTypes[card.type];
								return React.createElement('div', {
									key: card.id,
									className: 'card',
									onClick: () => onRemoveCard(card),
									style: {
										backgroundColor: '#444',
										padding: '15px',
										borderRadius: '8px',
										cursor: 'pointer',
										transition: 'all 0.2s',
										border: '2px solid transparent',
										'&:hover': {
											transform: 'translateY(-5px)',
											borderColor: '#e74c3c',
											boxShadow: '0 0 15px rgba(231, 76, 60, 0.5)'
										}
									}
								},
									React.createElement('h3', null, cardType.name),
									React.createElement('p', null, `Cost: ${cardType.cost} Energy`),
									React.createElement('p', null, cardType.description)
								);
							})
						)
					)
				);
			};

			const VictoryOverlay = () => {
				return React.createElement('div', { className: 'victory-overlay' },
					React.createElement('div', { className: 'victory-content' },
						React.createElement('h2', null, `Round ${round} Completed!`),
						React.createElement('p', null, 'Choose a card to add to your deck:'),
						React.createElement('div', { className: 'rewards-container' },
							rewardOptions.map((cardType, index) => {
								const card = cardTypes[cardType];
								return React.createElement('div', {
									key: index,
									className: 'reward-card',
									onClick: () => selectReward(cardType)
								},
									React.createElement('h3', null, card.name),
									React.createElement('p', null, `Cost: ${card.cost} Energy`),
									React.createElement('p', null, card.description)
								);
							})
						)
					)
				);
			};
			
			
			
			const DefeatOverlay = () => {
				const returnToMenu = () => {
					// Reset game states
					setGameOver(false);
					setPlayerHealth(100);
					setPlayerEnergy(3);
					setRound(1);
					setEmpowerActive(false);
					setCounterActive(false);
					setHand([]);
					setDiscardPile([]);
					setSelectedCard(null);
					setSelectedCardIndex(null);
					setIsTargeting(false);
					
					// Return to main menu
					setCurrentScreen('menu');
				};

				return React.createElement('div', { className: 'victory-overlay' },
					React.createElement('div', { className: 'victory-content' },
						React.createElement('h2', { 
							style: { 
								color: '#ff4444',
								fontSize: '2em',
								marginBottom: '20px'
							} 
						}, 'Defeat!'),
						React.createElement('p', null, `You were defeated on round ${round}!`),
						React.createElement('button', {
							className: 'button',
							onClick: returnToMenu,
							style: {
								fontFamily: 'Cinzel, serif',
								fontSize: '1.5rem',
								color: '#fff',
								backgroundColor: '#e74c3c',
								border: 'none',
								padding: '1rem 3rem',
								borderRadius: '8px',
								cursor: 'pointer',
								marginTop: '2rem',
								transition: 'all 0.3s ease',
								textShadow: '0 0 10px rgba(231, 76, 60, 0.5)',
								boxShadow: '0 0 15px rgba(231, 76, 60, 0.3)',
							},
							onMouseOver: (e) => {
								e.target.style.transform = 'scale(1.05)';
								e.target.style.boxShadow = '0 0 25px rgba(231, 76, 60, 0.5)';
							},
							onMouseOut: (e) => {
								e.target.style.transform = 'scale(1)';
								e.target.style.boxShadow = '0 0 15px rgba(231, 76, 60, 0.3)';
							}
						}, 'Return to Main Menu')
					)
				);
			};

            // Replace the return statement in your Game component with this fixed version:
			return React.createElement('div', { className: 'game-container' },
			  currentScreen === 'splash' ? React.createElement('div', { 
				className: 'main-menu',
				style: { cursor: 'pointer' }
			  },
				React.createElement('div', { className: 'game-title' }, 'RAID BOSS'),
				React.createElement('div', { className: 'press-any-key' }, 'Press Any Key or Click to Start Game')
			  ) : currentScreen === 'menu' ? React.createElement(MainMenu, {
				onStartRun: handleStartRun,
				onTalents: handleTalents
			  }) : currentScreen === 'talents' ? React.createElement(TalentsScreen) : React.createElement(React.Fragment, null,
				showPreBossFight && React.createElement(PreBossFight, {
				  currentHealth: playerHealth,
				  maxHealth: maxHealth
				}),
				showCardRemoval && React.createElement(CardRemovalOverlay, {
				  deck: deck,
				  hand: hand,
				  discardPile: discardPile,
				  onRemoveCard: handleCardRemoval
				}),
				showSpecialRewards && React.createElement(SpecialRewardsOverlay, {
				  rewards: specialRewardOptions,
				  onSelectReward: handleSpecialReward,
				  remainingPicks: specialRewardOptions.length === 5 ? 2 : 1
				}),
				// Rest of your game UI elements
				isTargeting && React.createElement('div', { 
				  className: 'targeting-message'
				}, 'Select an enemy to target'),
				showVictory && React.createElement(VictoryOverlay),
				gameOver && React.createElement(DefeatOverlay),
				showStatusMessage && React.createElement('div', { 
				  className: 'targeting-message'
				}, statusMessage),
				showEnergyGain && React.createElement('div', { 
				  className: 'energy-gain' 
				}, '+2 Energy'),
					
					

					// Top status bar
					React.createElement('div', { className: 'status-bar' },
					  React.createElement('div', null,
						React.createElement('h2', null, `Player Health: ${playerHealth}`),
						React.createElement('div', { 
						  style: { display: 'flex', alignItems: 'center' }
						}, 
						  Array(3).fill().map((_, i) => 
							React.createElement('span', {
							  key: i,
							  className: `energy-orb ${i >= Math.min(playerEnergy, 3) ? 'empty' : ''}`
							})
						  ),
						  playerEnergy > 3 && React.createElement('span', {
							style: {
							  marginLeft: '10px',
							  color: '#3498db',
							  fontWeight: 'bold',
							  fontSize: '1.2em'
							}
						  }, `+${playerEnergy - 3}`)
						)
					  ),
					  React.createElement('div', { 
						style: { 
						  display: 'flex', 
						  gap: '20px', 
						  alignItems: 'center' 
						} 
					  },
						React.createElement('div', { className: 'round-counter' },
						  `Round ${round}`
						),
						React.createElement('div', null,
						  `🧠 ${knowledgePoints}`,
						  ' | ',
						  `⭐ ${skillPoints}`
						)
					  ),
					  React.createElement('button', {
						className: 'button',
						onClick: endTurn,
						disabled: !canEndTurn
					  }, 'End Turn')
					),

					// Enemies container
					React.createElement('div', { className: 'enemies-container' },
						enemies.length > 0 ? enemies.map((enemy, index) => 
							React.createElement('div', { 
								key: index,
								className: `${enemy.isBoss ? 'boss-card' : 'enemy-card'} ${isTargeting ? 'targetable' : ''}`,
								onClick: () => {
									if (isTargeting && selectedCard) {
										const cardDef = cardTypes[selectedCard.type];
										const discountType = discountedCards.get(selectedCard.id);
										let currentCost = cardDef.cost;
										if (discountType === "zero") {
											currentCost = 0;
										} else if (discountType === "reduced") {
											currentCost = Math.max(0, cardDef.cost - 1);
										}
										if (playerEnergy >= currentCost) {
											selectTarget(index);
										}
									}
								}
							},
								React.createElement('p', {
									style: enemy.isBoss ? {
										fontSize: '1.5em',
										color: '#ff4444',
										fontWeight: 'bold',
										marginBottom: '10px'
									} : null
								}, enemy.isBoss ? 'Raid Boss' : `Enemy ${index + 1}`),
								React.createElement('div', { className: 'health-bar' },
									React.createElement('div', {
										className: 'health-bar-fill',
										style: { 
											width: `${(enemy.health / enemy.maxHealth) * 100}%`,
											backgroundColor: enemy.isBoss ? '#ff4444' : '#4CAF50'
										}
									})
								),
								React.createElement('p', null, `HP: ${enemy.health}/${enemy.maxHealth}`),
								enemy.isBoss && React.createElement('p', {
									style: {
										color: '#ff4444',
										fontWeight: 'bold'
									}
								}, `Phase ${enemy.phase}`),
								enemy.isBoss && enemy.intents && enemy.intents[0] && 
									React.createElement('div', {
										className: `boss-intent intent-${enemy.intents[0].type}`
									}, enemy.intents[0].description),
								!enemy.isBoss && React.createElement('p', null, `Intent: ${enemy.intent}`),
								enemy.damageNumbers && enemy.damageNumbers.map(damageNum => 
									React.createElement('div', {
										key: damageNum.id,
										className: 'damage-number',
										style: {
											left: `${Math.random() * 60 + 20}%`
										}
									}, `-${damageNum.amount}`)
								)
							)
						) : React.createElement('p', null, 'Summoning enemies...')
					),

					// Hand container
					React.createElement('div', { className: 'hand-container' },
						hand.map((card, index) => {
							const cardType = cardTypes[card.type];
							const discountType = discountedCards.get(card.id);
							let currentCost = cardType.cost;
							if (discountType === "zero") {
								currentCost = 0;
							} else if (discountType === "reduced") {
								currentCost = Math.max(0, cardType.cost - 1);
							}
							const canPlay = playerEnergy >= currentCost;
							
							return React.createElement('div', {
								key: card.id,
								className: `card ${!canPlay ? 'disabled' : ''} ${selectedCardIndex === index ? 'selected' : ''}`,
								onClick: () => canPlay && selectCard(card, index)
							},
								React.createElement('h3', null, cardType.name),
								React.createElement('p', null, 
									discountType === "zero" ? 
										React.createElement('span', { style: { color: '#4CAF50' } }, 'Cost: 0 Energy (free)') :
									discountType === "reduced" ? 
										React.createElement('span', { style: { color: '#4CAF50' } }, `Cost: ${currentCost} Energy (reduced)`) :
										`Cost: ${currentCost} Energy`
								),
								React.createElement('p', null, cardType.description)
							);
						})
					),

					// Bottom status bar
					React.createElement('div', { className: 'status-bar' },
						React.createElement('div', { style: { display: 'flex', gap: '20px' } },
							React.createElement('p', null, `Total Cards: ${deck.length + hand.length + discardPile.length + exhaustedCards.length}`),
							React.createElement('p', null, `Deck: ${deck.length}`),
							React.createElement('p', null, `Hand: ${hand.length}`),
							React.createElement('p', null, `Discard: ${discardPile.length}`),
							React.createElement('p', null, `Exhausted: ${exhaustedCards.length}`)
						),
						React.createElement('div', { style: { display: 'flex', gap: '10px' } },
							empowerActive && React.createElement('span', { className: 'status-effect empower' }, 'Empower Active!'),
							counterActive && React.createElement('span', { className: 'status-effect counter' }, 'Counter Active!'),
							playerWeakened && React.createElement('span', { 
								className: 'status-effect weakened',
								style: {
									backgroundColor: '#8b0000',
									color: 'white',
									padding: '5px 10px',
									borderRadius: '4px'
								}
							}, 'Weakened: -1 Damage')
						)
					)
				)
			);
        };
		
				
		
        ReactDOM.render(
            React.createElement(Game),
            document.getElementById('game-root')
        );
    </script>
</body>
</html>